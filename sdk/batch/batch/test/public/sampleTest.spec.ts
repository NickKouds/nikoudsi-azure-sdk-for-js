/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import {
  env,
  record,
  RecorderEnvironmentSetup,
  Recorder,
  delay,
  isPlaybackMode
} from "@azure-tools/test-recorder";
import { v4 as uuid } from "uuid";
import { createRecorder, createClient } from "./utils/recordedClient"
import { assert } from "chai";
import { BatchServiceClient } from "../../src/batchServiceClient";
import { wait } from "./utils/wait";
import { Pool, CertificateAddParameter, PoolGetOptionalParams, PoolUpdate } from "../../src/generated/models";
import { errorMonitor } from "events";

//const wait = (timeout = 1000) => new Promise((resolve) => setTimeout(() => resolve(null), timeout));

const _SUFFIX = Math.random()
  .toString(16)
  .substr(2, 4);


function getPoolName(type: string) {
  return `jssdktest-${type}-${_SUFFIX}`;
}

const BASIC_POOL = getPoolName("basic");
const VNET_POOL = getPoolName("vnet");
const IMAGE_POOL = getPoolName("image");
const DISK_POOL = getPoolName("datadisk");
const BASIC_POOL_NUM_VMS = 4;
const JOB_NAME = `JSSDKTestJob-${_SUFFIX}`;
const TASK_NAME = `${JOB_NAME}-task1`;
const TASK_UPDATE_OPTIONS = {
  constraints: { maxTaskRetryCount: 3 }
};
const TASK2_NAME = `${JOB_NAME}-task2`;
const TASK3_NAME = `${JOB_NAME}-task3`;
const TASK_APPPACK_NAME = `${JOB_NAME}-Task-AppPackage`;
const SCHEDULE = "JSSDKTestSchedule";
const TEST_USER = "JSSDKTestSchedule";
const VMSIZE_A1 = "Standard_A1_v2";
const VMSIZE_D1 = "Standard_D1_v2";
const VMSIZE_SMALL = "Small";

const POLLING_INTERVAL = 5000;
const LONG_TEST_TIMEOUT = 1000000;

describe("Batch Service Test", () => {
  let recorder: Recorder;
  let client: BatchServiceClient;

  let certThumb: string = "cff2ab63c8c955aaf71989efa641b906558d9fb7";
  let nonAdminPoolUser: string = "nonAdminUser";
  let compute_nodes: string[];

  beforeEach(async function () {
    recorder = createRecorder(this);
    client = createClient("APIKey");

  });

  afterEach(async function () {
    await recorder.stop();
  });

  describe("Certificate operations", () => {
    it("should list supported images successfully", async () => {
      const supportedImages = await client.account.listSupportedImages();

      for await (const image of supportedImages) {
        assert.isNotNull(image.nodeAgentSKUId);
        assert.isNotNull(image.osType);

      }

    });

    it("should add new certificate successfully", async () => {
      const cert: CertificateAddParameter = {
        thumbprint: certThumb,
        thumbprintAlgorithm: "sha1",
        password: "nodesdk",
        certificateFormat: "pfx",
        data:
          "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"
      };

      await client.certificate.add(cert);
    });

    it("should list certificates successfully", async () => {
      const result = await client.certificate.list();
      let certCounter = 0;
      for await (const cert of result) {
        assert.equal(cert.thumbprint, certThumb);
        assert.equal(cert.thumbprintAlgorithm, "sha1");
        ++certCounter;
      }

      assert.isAtLeast(certCounter, 1);

    });

    it("should get certificate reference successfully", async () => {
      const result = await client.certificate.get("sha1", certThumb);
      assert.equal(result.thumbprint, certThumb);
      assert.equal(result.thumbprintAlgorithm, "sha1");
    });

  })

  describe("Authentication", () => {
    it("Should perform AAD authentication successfully.", async function () {
      const aadClient = createClient("AAD");
      const supportedImages = aadClient.account.listSupportedImages();

      for await (const image of supportedImages) {
        assert.isNotNull(image.nodeAgentSKUId);
        assert.isNotNull(image.osType);

      }
    })
  })

  describe("Basic Pool operations", () => {
    it("Create Batch Pool successfully", async function () {
      // Use assert to test your assumptions
      const poolParams: Pool = {
        id: BASIC_POOL,
        vmSize: VMSIZE_D1,
        cloudServiceConfiguration: { osFamily: "4" },
        targetDedicatedNodes: BASIC_POOL_NUM_VMS,
        certificateReferences: [{ thumbprint: certThumb, thumbprintAlgorithm: "sha1" }],
        // Ensures there's a compute node file we can reference later
        startTask: { commandLine: "cmd /c echo hello > hello.txt" },
        // Sets up pool user we can reference later
        userAccounts: [
          {
            name: nonAdminPoolUser,
            password: uuid(),
            elevationLevel: "nonadmin"
          }
        ]
      }

      try {
        const result = await client.pool.add(poolParams);
      }
      catch (error) {
        console.log(error);
      }

      await wait(20000);


    });

    it("should patch pool parameters successfully", async () => {
      const options: PoolUpdate = {
        metadata: [
          {
            name: "foo2",
            value: "bar2"
          }
        ]
      };

      await client.pool.patch(BASIC_POOL, options);
      const result = await client.pool.get(BASIC_POOL);
      assert.equal(result.id, BASIC_POOL);
      assert.equal(result.state, "active");

      for (let index = 0; index < options.metadata!.length; index++) {
        assert.equal(result.metadata![index].name, options.metadata![index].name);
        assert.equal(result.metadata![index].value, options.metadata![index].value);
      }

    });

    it("should get a pool reference successfully", async () => {
      let result: any;
      let metadata: any;

      const promise = new Promise<void>((resolve) => {
        const timeout = setInterval(async () => {
          result = await client.pool.get(BASIC_POOL);
          metadata = result.metadata![0];
          if (result.allocationState === "steady") {
            resolve();
            clearTimeout(timeout);
          }
        }, POLLING_INTERVAL);
      });

      await promise;

      assert.equal(result.id, BASIC_POOL);
      assert.equal(result.state, "active");
      assert.equal(result.allocationState, "steady");
      assert.isDefined(result.cloudServiceConfiguration);
      assert.equal(result.cloudServiceConfiguration!.osFamily, "4");
      assert.equal(result.vmSize.toLowerCase(), VMSIZE_D1.toLowerCase());

      assert.equal(metadata.name, "foo2");
      assert.equal(metadata.value, "bar2");

      assert.isDefined(result.startTask);
      assert.equal(result.startTask!.commandLine, "cmd /c echo hello > hello.txt");

      assert.lengthOf(result.userAccounts!, 1);
      assert.equal(result.userAccounts![0].name, nonAdminPoolUser);
      assert.equal(result.userAccounts![0].elevationLevel, "nonadmin");
    }).timeout(LONG_TEST_TIMEOUT);

    it("Get Batch Pool Info", async function () {
      // Use assert to test your assumptions
      const result = await client.pool.get(BASIC_POOL)

      assert.equal(result.id, BASIC_POOL);
      assert.equal(result.state, "active");
      assert.isDefined(result.cloudServiceConfiguration);
      assert.equal(result.targetDedicatedNodes, BASIC_POOL_NUM_VMS);
      assert.isFalse(result.enableAutoScale);
      assert.oneOf(result.allocationState, ["resizing", "steady"])

    });

    it("should update pool parameters successfully", async () => {
      const options: Pool = {
        metadata: [{ name: "foo", value: "bar" }],
        certificateReferences: [],
        applicationPackageReferences: [],
        // Ensures the start task isn't cleared
        startTask: { commandLine: "cmd /c echo hello > hello.txt" }
      };

      const result = await client.pool.updateProperties(BASIC_POOL, options);
    });

    it("should get a pool reference with odata successfully", async () => {
      const options: PoolGetOptionalParams = {
        poolGetOptions: { select: "id,state", expand: "stats" }
      };

      const result = await client.pool.get(BASIC_POOL, options);
      assert.equal(result.id, BASIC_POOL);
      assert.equal(result.state, "active");
      assert.isUndefined(result.allocationState);
      assert.isUndefined(result.vmSize);
    });

    it("should add a pool with vnet and get expected error", async () => {
      const pool: Pool = {
        id: VNET_POOL,
        vmSize: VMSIZE_A1,
        cloudServiceConfiguration: { osFamily: "4" },
        targetDedicatedNodes: 0,
        networkConfiguration: {
          subnetId:
            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/test/providers/Microsoft.Network/virtualNetworks/vnet1/subnets/subnet1"
        }
      };

      try {
        await client.pool.add(pool);
        assert.fail("Expected error to be thrown");
      } catch (error: any) {
        assert.equal(error.statusCode, 403);
        assert.equal(error.details.code, "Forbidden");
      }
    });

    it("should add a pool with a custom image and get expected error", async () => {
      const pool: Pool = {
        id: IMAGE_POOL,
        vmSize: VMSIZE_A1,
        virtualMachineConfiguration: {
          imageReference: {
            virtualMachineImageId:
              "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/test/providers/Microsoft.Compute/images/FakeImage"
          },
          nodeAgentSKUId: "batch.node.ubuntu 16.04"
        },
        targetDedicatedNodes: 0
      };

      try {
        await client.pool.add(pool);
        assert.fail("Expected error to be thrown");
      } catch (error: any) {
        assert.equal(error.statusCode, 400);
        assert.equal(error.details.code, "InvalidPropertyValue");
        assert.equal(error.details.values[0].value, "virtualMachineImageId");
      }
    });

    it("should add a pool with a Data Disk", async () => {
      const pool: Pool = {
        id: DISK_POOL,
        vmSize: VMSIZE_A1,
        virtualMachineConfiguration: {
          imageReference: {
            publisher: "Canonical",
            offer: "UbuntuServer",
            sku: "18.04-LTS"
          },
          nodeAgentSKUId: "batch.node.ubuntu 18.04",
          dataDisks: [
            {
              lun: 1,
              diskSizeGB: 50
            }
          ]
        },
        targetDedicatedNodes: 0
      };

      const resultAdd = await client.pool.add(pool);

      await wait(POLLING_INTERVAL);

      const resultGet = await client.pool.get(pool.id!);
      assert.equal(resultGet.virtualMachineConfiguration!.dataDisks![0].lun, 1);
      assert.equal(resultGet.virtualMachineConfiguration!.dataDisks![0].diskSizeGB, 50);

      const resultDelete = await client.pool.delete(pool.id!);
    });

  })

  describe("Job operations (basic)", async () => {
    it("should create a job successfully", async () => {
      const options = { id: JOB_NAME, poolInfo: { poolId: BASIC_POOL } };
      const result = await client.job.add(options);

      const getResult = await client.job.get(JOB_NAME);
      assert.equal(getResult.state, "active");
      assert.equal(getResult.poolInfo?.poolId, BASIC_POOL);
      assert.equal(getResult.allowTaskPreemption, false);

    });

    it("should update a job successfully", async () => {
      const options = {
        priority: 500,
        constraints: { maxTaskRetryCount: 3 },
        poolInfo: { poolId: BASIC_POOL }
      };

      try {
        const result = await client.job.update(JOB_NAME, options);
      }
      catch (error) {
        console.log(error);
        throw error
      }


    });

  });

  describe("Task operations", async () => {
    it("should create a task successfully", async () => {
      const task = {
        id: TASK_NAME,
        commandLine: "cmd /c echo hello > hello.txt"
      };
      const result = await client.task.add(JOB_NAME, task);
    });

    it("should update a task successfully", async () => {
      try {
        const result = await client.task.update(JOB_NAME, TASK_NAME, TASK_UPDATE_OPTIONS);
      }
      catch (error) {
        console.log(error);
        throw error

      }

    });

    it("should get task reference successfully", async () => {
      const result = await client.task.get(JOB_NAME, TASK_NAME);

      assert.equal(result.id, TASK_NAME);
      assert.equal(result.constraints?.maxTaskRetryCount, TASK_UPDATE_OPTIONS.constraints.maxTaskRetryCount);

    });

    it("should create a task with container settings successfully", async () => {
      const taskSettings = {
        id: TASK2_NAME,
        commandLine: "cat /etc/centos-release",
        containerSettings: { imageName: "centos" }
      };
      try {
        const result2 = await client.task.add(JOB_NAME, taskSettings);
        const getResult = await client.task.get(JOB_NAME, taskSettings.id);
        assert.equal(getResult.containerSettings?.imageName, taskSettings.containerSettings.imageName);
        assert.equal(getResult.commandLine, taskSettings.commandLine);

        await client.task.delete(JOB_NAME, TASK2_NAME);
      }
      catch (error) {
        console.log(error)
      }

    });

    it("should add a task with an application package reference successfully", async () => {
      const task = {
        id: TASK_APPPACK_NAME,
        commandLine: "cmd /c echo hello world",
        applicationPackageReferences: [
          {
            applicationId: "my_application_id"
          }
        ]
      };
      try {
        const result1 = await client.task.add(JOB_NAME, task);
        const result2 = await client.task.get(JOB_NAME, TASK_APPPACK_NAME);
        assert.isDefined(result2.applicationPackageReferences);
      }
      catch (error) {
        console.log(error)
      }

    });

  });

  // describe("Compute node operations", async () => {
  //   it("should list compute nodes successfully", async () => {
  //     let listResult;
  //     let nodeCounter = 0;
  //     let singleNode;
  //     listResult = await client.computeNode.list(BASIC_POOL);

  //     for await (const node of listResult) {
  //       nodeCounter += 1;
  //     }

  //     assert.equal(nodeCounter, BASIC_POOL_NUM_VMS);

  //     let nodesProvisioning: Boolean = true;
  //     while (nodesProvisioning) {
  //       listResult = await client.computeNode.list(BASIC_POOL);
  //       for await (const node of listResult) {
  //         if (node.state === "starting") {
  //           await wait(POLLING_INTERVAL);
  //           break;
  //         }
  //         else {
  //           compute_nodes.push(node.id!);
  //           nodesProvisioning = false;
  //           assert.equal(node.state, "idle");
  //           assert.equal(node.schedulingState, "enabled");
  //           assert.isTrue(node.isDedicated);
  //           break;
  //         }
  //       }

  //     }

  //   }).timeout(LONG_TEST_TIMEOUT);

  //   it("should get a compute node reference", async () => {
  //     const result = await client.computeNode.get(BASIC_POOL, compute_nodes[0]);
  //     assert.equal(result.id, compute_nodes[0]);
  //     assert.equal(result.state, "idle");
  //     assert.equal(result.schedulingState, "enabled");
  //     assert.equal(result._response.status, 200);
  //   });

  //   it("should get a compute node reference", async () => {
  //     const result = await client.computeNode.get(BASIC_POOL, compute_nodes[0]);

  //     assert.equal(result.id, compute_nodes[0]);
  //     assert.equal(result.state, "idle");
  //     assert.equal(result.schedulingState, "enabled");
  //     assert.equal(result._response.status, 200);
  //   });

  //   it("should add a user to a compute node successfully", async () => {
  //     const options = { name: TEST_USER, isAdmin: false, password: "kt#_gahr!@aGERDXA" };
  //     const result = await client.computeNode.addUser(BASIC_POOL, compute_nodes[0], options);

  //     assert.equal(result._response.status, 201);
  //   });

  //   it("should update a compute node user successfully", async () => {
  //     const options = { password: "liilef#$DdRGSa_ewkjh" };
  //     const result = await client.computeNode.updateUser(
  //       BASIC_POOL,
  //       compute_nodes[0],
  //       TEST_USER,
  //       options
  //     );

  //     assert.equal(result._response.status, 200);
  //   });

  //   it("should get a remote desktop file successfully", (done) => {
  //     client.computeNode
  //       .getRemoteDesktop(BASIC_POOL, compute_nodes[0])
  //       .then((result) => {
  //         assert.equal(result._response.status, 200);
  //         readStreamToBuffer(result.readableStreamBody!, function (_err, buff) {
  //           assert.isAtLeast(buff.length, 1);
  //           done();
  //         });
  //       })
  //       .catch((error) => {
  //         assert.fail(error);
  //       });
  //   });

  //   it("should delete a compute node user successfully", async () => {
  //     const result = await client.computeNode.deleteUser(BASIC_POOL, compute_nodes[0], TEST_USER);

  //     assert.equal(result._response.status, 200);
  //   });

  //   it("should disable scheduling on a compute node successfully", async () => {
  //     while (true) {
  //       try {
  //         const result = await client.computeNode.disableScheduling(BASIC_POOL, compute_nodes[1]);
  //         assert.equal(result._response.status, 200);
  //         break;
  //       } catch (e: any) {
  //         if (e.code === "NodeNotReady") {
  //           await wait(POLLING_INTERVAL);
  //         } else {
  //           throw e;
  //         }
  //       }
  //     }
  //   });

  //   it("should enable scheduling on a compute node successfully", async () => {
  //     const result = await client.computeNode.enableScheduling(BASIC_POOL, compute_nodes[1]);

  //     assert.equal(result._response.status, 200);
  //   });

  //   it("should reboot a compute node successfully", async () => {
  //     const result = await client.computeNode.reboot(BASIC_POOL, compute_nodes[0]);

  //     assert.equal(result._response.status, 202);
  //   });

  //   it("should reimage a compute node successfully", async () => {
  //     const result = await client.computeNode.reimage(BASIC_POOL, compute_nodes[1]);

  //     assert.equal(result._response.status, 202);
  //   });

  //   it("should upload pool node logs at paas pool", async () => {
  //     const container = "https://teststorage.blob.core.windows.net/fakecontainer";
  //     const config: BatchServiceModels.UploadBatchServiceLogsConfiguration = {
  //       containerUrl: container,
  //       startTime: new Date("2018-02-25T00:00:00.00")
  //     };
  //     const result = await client.computeNode.uploadBatchServiceLogs(
  //       BASIC_POOL,
  //       compute_nodes[2],
  //       config
  //     );

  //     assert.equal(result._response.status, 200);
  //     assert.isAtLeast(result.numberOfFilesUploaded, 1);
  //   });
  // });

  describe("Resource cleanup", () => {
    it("Delete Batch Pool", async function () {
      await client.pool.delete(BASIC_POOL);
    });

    it("Delete Batch Task", async function () {
      await client.task.delete(JOB_NAME, TASK_NAME);
    });

    it("Delete Batch Job", async function () {
      const result = await client.job.delete(JOB_NAME);
    })

    it("Delete Certifcate", async function () {
      const result = await client.certificate.delete("sha1", certThumb);
    })
  })




})
