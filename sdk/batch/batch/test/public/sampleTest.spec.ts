/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import {
  env,
  record,
  RecorderEnvironmentSetup,
  Recorder,
  delay,
  isPlaybackMode
} from "@azure-tools/test-recorder";
import { v4 as uuid } from "uuid";
import { createRecorder, createClient } from "./utils/recordedClient"
import { assert } from "chai";
import { BatchServiceClient } from "../../src/batchServiceClient";
import { wait } from "./utils/wait";
import { Pool, CertificateAddParameter, PoolGetOptionalParams, PoolUpdate, JobSchedule, Job, Task, TaskGetResponse, NodeRemoveParameter } from "../../src/generated/models";
import { duration } from "moment";
import moment from "moment";
import { PagedAsyncIterableIterator } from "@azure/core-paging";
import { Console } from "console";

//const wait = (timeout = 1000) => new Promise((resolve) => setTimeout(() => resolve(null), timeout));

const _SUFFIX = Math.random()
  .toString(16)
  .substr(2, 4);

async function getListObj(objIterator: PagedAsyncIterableIterator<any>): Promise<Array<any>> {
  let objList = [];

  for await (const obj of objIterator) {
    objList.push(obj);
  }

  return objList;

}

async function getListPagedCount(objIterator: PagedAsyncIterableIterator<any>): Promise<number> {
  let objCounter = 0;

  for await (const obj of objIterator) {
    ++objCounter;
  }

  return objCounter;
}

function getPoolName(type: string) {
  return `jssdktest-${type}-${_SUFFIX}`;
}

const BASIC_POOL = getPoolName("basic");
const ENDPOINT_POOL = getPoolName("endpoint");
const VNET_POOL = getPoolName("vnet");
const IMAGE_POOL = getPoolName("image");
const DISK_POOL = getPoolName("datadisk");
const ADVANCED_POOL = getPoolName("Advanced");
const BASIC_POOL_NUM_VMS = 4;
const JOB_NAME = `JSSDKTestJob-${_SUFFIX}`;
const TASK_NAME = `${JOB_NAME}-task1`;
const TASK_UPDATE_OPTIONS = {
  constraints: { maxTaskRetryCount: 3 }
};
const TASK2_NAME = `${JOB_NAME}-task2`;
const TASK3_NAME = `${JOB_NAME}-task3`;
const TASK_APPPACK_NAME = `${JOB_NAME}-Task-AppPackage`;
const SCHEDULE = "JSSDKTestSchedule";
const TEST_USER = "JSSDKTestSchedule";
const VMSIZE_A1 = "Standard_A1_v2";
const VMSIZE_D1 = "Standard_D1_v2";
const VMSIZE_SMALL = "Small";

const POLLING_INTERVAL = 5000;
const LONG_TEST_TIMEOUT = 1000000;

describe("Batch Service Test", () => {
  let recorder: Recorder;
  let client: BatchServiceClient;

  let certThumb: string = "cff2ab63c8c955aaf71989efa641b906558d9fb7";
  let nonAdminPoolUser: string = "nonAdminUser";
  let compute_nodes: string[];

  const readStreamToBuffer = function (
    strm: NodeJS.ReadableStream,
    callback: (_a: any, buf: Buffer) => void
  ) {
    const bufs: any[] = [];
    strm.on("data", function (d) {
      bufs.push(d);
    });
    strm.on("end", function () {
      callback(null, Buffer.concat(bufs));
    });
  };

  beforeEach(async function () {
    recorder = createRecorder(this);
    client = createClient("APIKey");

  });

  afterEach(async function () {
    await recorder.stop();
  });

  describe("Certificate operations", () => {
    it("should list supported images successfully", async () => {
      const supportedImages = await client.account.listSupportedImages();

      for await (const image of supportedImages) {
        assert.isNotNull(image.nodeAgentSKUId);
        assert.isNotNull(image.osType);

      }

    });

    it("should add new certificate successfully", async () => {
      const cert: CertificateAddParameter = {
        thumbprint: certThumb,
        thumbprintAlgorithm: "sha1",
        password: "nodesdk",
        certificateFormat: "pfx",
        data:
          "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"
      };

      await client.certificate.add(cert);
    });

    it("should list certificates successfully", async () => {
      const result = await client.certificate.list();
      let certCounter = 0;
      for await (const cert of result) {
        assert.equal(cert.thumbprint, certThumb);
        assert.equal(cert.thumbprintAlgorithm, "sha1");
        ++certCounter;
      }

      assert.isAtLeast(certCounter, 1);

    });

    it("should get certificate reference successfully", async () => {
      const result = await client.certificate.get("sha1", certThumb);
      assert.equal(result.thumbprint, certThumb);
      assert.equal(result.thumbprintAlgorithm, "sha1");
    });

  })

  describe.skip("Authentication", () => {
    it("Should perform AAD authentication successfully.", async function () {
      const aadClient = createClient("AAD");
      const supportedImages = aadClient.account.listSupportedImages();

      for await (const image of supportedImages) {
        assert.isNotNull(image.nodeAgentSKUId);
        assert.isNotNull(image.osType);

      }
    })
  })

  describe("Basic Pool operations", () => {
    it("Create Batch Pool successfully", async function () {
      // Use assert to test your assumptions
      const poolParams: Pool = {
        id: BASIC_POOL,
        vmSize: VMSIZE_D1,
        cloudServiceConfiguration: { osFamily: "4" },
        targetDedicatedNodes: BASIC_POOL_NUM_VMS,
        certificateReferences: [{ thumbprint: certThumb, thumbprintAlgorithm: "sha1" }],
        // Ensures there's a compute node file we can reference later
        startTask: { commandLine: "cmd /c echo hello > hello.txt" },
        // Sets up pool user we can reference later
        userAccounts: [
          {
            name: nonAdminPoolUser,
            password: uuid(),
            elevationLevel: "nonadmin"
          }
        ]
      }

      try {
        const result = await client.pool.add(poolParams);
      }
      catch (error) {
        console.log(error);
      }

      await wait(20000);


    });

    it("should patch pool parameters successfully", async () => {
      const options: PoolUpdate = {
        metadata: [
          {
            name: "foo2",
            value: "bar2"
          }
        ]
      };

      await client.pool.patch(BASIC_POOL, options);
      const result = await client.pool.get(BASIC_POOL);
      assert.equal(result.id, BASIC_POOL);
      assert.equal(result.state, "active");

      for (let index = 0; index < options.metadata!.length; index++) {
        assert.equal(result.metadata![index].name, options.metadata![index].name);
        assert.equal(result.metadata![index].value, options.metadata![index].value);
      }

    });

    it("should get a pool reference successfully", async () => {
      let result: any;
      let metadata: any;

      const promise = new Promise<void>((resolve) => {
        const timeout = setInterval(async () => {
          result = await client.pool.get(BASIC_POOL);
          metadata = result.metadata![0];
          if (result.allocationState === "steady") {
            resolve();
            clearTimeout(timeout);
          }
        }, POLLING_INTERVAL);
      });

      await promise;

      assert.equal(result.id, BASIC_POOL);
      assert.equal(result.state, "active");
      assert.equal(result.allocationState, "steady");
      assert.isDefined(result.cloudServiceConfiguration);
      assert.equal(result.cloudServiceConfiguration!.osFamily, "4");
      assert.equal(result.vmSize.toLowerCase(), VMSIZE_D1.toLowerCase());

      assert.equal(metadata.name, "foo2");
      assert.equal(metadata.value, "bar2");

      assert.isDefined(result.startTask);
      assert.equal(result.startTask!.commandLine, "cmd /c echo hello > hello.txt");

      assert.lengthOf(result.userAccounts!, 1);
      assert.equal(result.userAccounts![0].name, nonAdminPoolUser);
      assert.equal(result.userAccounts![0].elevationLevel, "nonadmin");
    }).timeout(LONG_TEST_TIMEOUT);

    it("Get Batch Pool Info", async function () {
      // Use assert to test your assumptions
      const result = await client.pool.get(BASIC_POOL)

      assert.equal(result.id, BASIC_POOL);
      assert.equal(result.state, "active");
      assert.isDefined(result.cloudServiceConfiguration);
      assert.equal(result.targetDedicatedNodes, BASIC_POOL_NUM_VMS);
      assert.isFalse(result.enableAutoScale);
      assert.oneOf(result.allocationState, ["resizing", "steady"])

    });

    it("should update pool parameters successfully", async () => {
      const options: Pool = {
        metadata: [{ name: "foo", value: "bar" }],
        certificateReferences: [],
        applicationPackageReferences: [],
        // Ensures the start task isn't cleared
        startTask: { commandLine: "cmd /c echo hello > hello.txt" }
      };

      const result = await client.pool.updateProperties(BASIC_POOL, options);
    });

    it("should get a pool reference with odata successfully", async () => {
      const options: PoolGetOptionalParams = {
        poolGetOptions: { select: "id,state", expand: "stats" }
      };

      const result = await client.pool.get(BASIC_POOL, options);
      assert.equal(result.id, BASIC_POOL);
      assert.equal(result.state, "active");
      assert.isUndefined(result.allocationState);
      assert.isUndefined(result.vmSize);
    });

    it("should add a pool with vnet and get expected error", async () => {
      const pool: Pool = {
        id: VNET_POOL,
        vmSize: VMSIZE_A1,
        cloudServiceConfiguration: { osFamily: "4" },
        targetDedicatedNodes: 0,
        networkConfiguration: {
          subnetId:
            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/test/providers/Microsoft.Network/virtualNetworks/vnet1/subnets/subnet1"
        }
      };

      try {
        await client.pool.add(pool);
        assert.fail("Expected error to be thrown");
      } catch (error: any) {
        assert.equal(error.statusCode, 403);
        assert.equal(error.details.code, "Forbidden");
      }
    });

    it("should add a pool with a custom image and get expected error", async () => {
      const pool: Pool = {
        id: IMAGE_POOL,
        vmSize: VMSIZE_A1,
        virtualMachineConfiguration: {
          imageReference: {
            virtualMachineImageId:
              "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/test/providers/Microsoft.Compute/images/FakeImage"
          },
          nodeAgentSKUId: "batch.node.ubuntu 16.04"
        },
        targetDedicatedNodes: 0
      };

      try {
        await client.pool.add(pool);
        assert.fail("Expected error to be thrown");
      } catch (error: any) {
        assert.equal(error.statusCode, 400);
        assert.equal(error.details.code, "InvalidPropertyValue");
        assert.equal(error.details.values[0].value, "virtualMachineImageId");
      }
    });

    it("should add a pool with a Data Disk", async () => {
      const pool: Pool = {
        id: DISK_POOL,
        vmSize: VMSIZE_A1,
        virtualMachineConfiguration: {
          imageReference: {
            publisher: "Canonical",
            offer: "UbuntuServer",
            sku: "18.04-LTS"
          },
          nodeAgentSKUId: "batch.node.ubuntu 18.04",
          dataDisks: [
            {
              lun: 1,
              diskSizeGB: 50
            }
          ]
        },
        targetDedicatedNodes: 0
      };

      const resultAdd = await client.pool.add(pool);

      await wait(POLLING_INTERVAL);

      const resultGet = await client.pool.get(pool.id!);
      assert.equal(resultGet.virtualMachineConfiguration!.dataDisks![0].lun, 1);
      assert.equal(resultGet.virtualMachineConfiguration!.dataDisks![0].diskSizeGB, 50);

      const resultDelete = await client.pool.delete(pool.id!);
    });

  })

  describe("Pool with endpoint configuration", async () => {
    it("should add a pool with inbound endpoint configuration successfully", async () => {
      const pool: Pool = {
        id: ENDPOINT_POOL,
        vmSize: VMSIZE_A1,
        networkConfiguration: {
          endpointConfiguration: {
            inboundNATPools: [
              {
                name: "TestEndpointConfig",
                protocol: "udp",
                backendPort: 64444,
                frontendPortRangeStart: 60000,
                frontendPortRangeEnd: 61000,
                networkSecurityGroupRules: [
                  {
                    priority: 150,
                    access: "allow",
                    sourceAddressPrefix: "*"
                  }
                ]
              }
            ]
          }
        },
        virtualMachineConfiguration: {
          nodeAgentSKUId: "batch.node.ubuntu 18.04",
          imageReference: {
            publisher: "Canonical",
            offer: "UbuntuServer",
            sku: "18.04-LTS"
          }
        },
        targetDedicatedNodes: 1
      };

      const result = await client.pool.add(pool);

      //assert.equal(result._response.status, 201);
    });

    it("should get the details of a pool with endpoint configuration successfully", async () => {
      let result;
      while (true) {
        let listResult = await client.computeNode.list(ENDPOINT_POOL);
        result = await getListObj(listResult)
        if (result.length > 0) {
          break;
        } else {
          await wait(POLLING_INTERVAL);
        }
      }
      assert.lengthOf(result, 1);
      assert.isDefined(result[0].endpointConfiguration);
      assert.lengthOf(result[0].endpointConfiguration!.inboundEndpoints, 2);
      assert.equal(
        result[0].endpointConfiguration!.inboundEndpoints[0].name,
        "TestEndpointConfig.0"
      );
      assert.equal(result[0].endpointConfiguration!.inboundEndpoints[0].protocol, "udp");
    });

    it("should get pool node counts successfully", async () => {
      let result;
      while (true) {
        let listResult = await client.account.listPoolNodeCounts();
        result = await getListObj(listResult);
        if (result.length > 0 && result[0].dedicated!.idle > 0) {
          break;
        } else {
          await wait(POLLING_INTERVAL);
        }
      }

      assert.isAtLeast(result.length, 1);
      //assert.equal(result._response.status, 200);

      const endpointPoolObj = result.filter(pool => pool.poolId == ENDPOINT_POOL);

      assert.isAbove(endpointPoolObj.length, 0, `Pool with Pool Id ${ENDPOINT_POOL} not found`);

      assert.equal(endpointPoolObj[0].dedicated!.idle, 1);
      assert.equal(endpointPoolObj[0].lowPriority!.total, 0);

    }).timeout(LONG_TEST_TIMEOUT);
  });

  describe("Job operations (basic)", async () => {
    it("should create a job successfully", async () => {
      const options = { id: JOB_NAME, poolInfo: { poolId: BASIC_POOL } };
      const result = await client.job.add(options);

      const getResult = await client.job.get(JOB_NAME);
      assert.equal(getResult.state, "active");
      assert.equal(getResult.poolInfo?.poolId, BASIC_POOL);
      assert.equal(getResult.allowTaskPreemption, false);

    });

    it("should update a job successfully", async () => {
      const options = {
        priority: 500,
        constraints: { maxTaskRetryCount: 3 },
        poolInfo: { poolId: BASIC_POOL }
      };

      try {
        const result = await client.job.update(JOB_NAME, options);
      }
      catch (error) {
        console.log(error);
        throw error
      }

    });

    it("should patch a job successfully", async () => {
      const options = {
        priority: 600,
        constraints: { maxTaskRetryCount: 3 },
        poolInfo: { poolId: BASIC_POOL }
      };
      const result = await client.job.update(JOB_NAME, options);

      //assert.equal(result._response.status, 200);
    });

  });

  describe("Task operations", async () => {
    it("should create a task with container settings successfully", async () => {
      const taskSettings = {
        id: TASK3_NAME,
        commandLine: "cat /etc/centos-release",
        containerSettings: { imageName: "centos" }
      };
      try {
        const result2 = await client.task.add(JOB_NAME, taskSettings);
        const getResult = await client.task.get(JOB_NAME, taskSettings.id);
        assert.equal(getResult.containerSettings?.imageName, taskSettings.containerSettings.imageName);
        assert.equal(getResult.commandLine, taskSettings.commandLine);

        await client.task.delete(JOB_NAME, TASK3_NAME);
      }
      catch (error) {
        console.log(error)
      }

    });

    it("should create a task with exit conditions successfully", async () => {

      const jobId = "JobWithAutoComplete";
      const taskId = "TaskWithAutoComplete";
      const job: Job = {
        id: jobId,
        poolInfo: {
          poolId: "dummypool"
        },
        onAllTasksComplete: "noaction",
        onTaskFailure: "performexitoptionsjobaction",
        usesTaskDependencies: true
      };

      try {
        const result1 = await client.job.add(job);

        const task: Task = {
          id: taskId,
          commandLine: "echo Hello World",
          exitConditions: {
            default: {
              jobAction: "terminate",
              dependencyAction: "satisfy"
            },
            exitCodes: [
              {
                code: 1,
                exitOptions: {
                  jobAction: "none",
                  dependencyAction: "block"
                }
              }
            ]
          }
        };

        await client.task.add(jobId, task);

        const result3 = await client.task.get(jobId, taskId);

        assert.equal(result3.exitConditions!.default!.jobAction, "terminate");
        assert.equal(result3.exitConditions!.default!.dependencyAction, "satisfy");
        assert.equal(result3.exitConditions!.exitCodes![0].code, 1);
        assert.equal(result3.exitConditions!.exitCodes![0].exitOptions.jobAction, "none");
        assert.equal(result3.exitConditions!.exitCodes![0].exitOptions.dependencyAction, "block");
      }
      catch (error) {
        console.log(error);
        throw error;
      }
      finally {
        await client.job.delete(jobId);
      }

    });


    it("should create a task successfully", async () => {
      const task = {
        id: TASK_NAME,
        commandLine: "cmd /c echo hello > taskHello.txt"
      };
      const result = await client.task.add(JOB_NAME, task);
    });

    it("should terminate a task successfully", async () => {
      const result = await client.task.terminate(JOB_NAME, TASK_NAME);
    });

    it("should create a second task with output files successfully", async () => {
      const container =
        "https://teststorage.blob.core.windows.net/batch-sdk-test?se=2017-05-05T23%3A48%3A11Z&sv=2016-05-31&sig=fwsWniANVb/KSQQdok%2BbT7gR79iiZSG%2BGkw9Rsd5efY";
      const outputs = [
        {
          filePattern: "../stdout.txt",
          destination: {
            container: { containerUrl: container, path: "taskLogs/output.txt", uploadHeaders: [{ name: "x-ms-blob-content-type", value: "text/plain" }, { name: "x-ms-blob-content-language", value: "en-US" },] }
          },
          uploadOptions: { uploadCondition: "taskCompletion" }
        },
        {
          file_pattern: "../stderr.txt",
          destination: {
            container: { containerUrl: container, path: "taskLogs/error.txt" }
          },
          uploadOptions: { uploadCondition: "taskFailure" }
        }
      ];
      const options = {
        id: TASK2_NAME,
        commandLine: "cmd /c echo hello world",
        output_files: outputs
      };

      const result = await client.task.add(JOB_NAME, options);

    });

    it("should reactivate a task successfully", async () => {
      const result = await client.task.reactivate(JOB_NAME, TASK_NAME);
    });

    it("should update a task successfully", async () => {
      const result = await client.task.update(JOB_NAME, TASK2_NAME, TASK_UPDATE_OPTIONS);
    });

    it("should list all tasks successfully", async () => {
      const result = await client.task.list(JOB_NAME);
      var taskCounter = 0;

      for await (const item of result) {
        assert.equal(item.constraints!.maxTaskRetryCount, TASK_UPDATE_OPTIONS.constraints.maxTaskRetryCount);
        ++taskCounter;
      }

      assert.equal(taskCounter, 2);
    });

    it("should get task reference successfully", async () => {
      const result = await client.task.get(JOB_NAME, TASK_NAME);

      assert.equal(result.id, TASK_NAME);
      assert.equal(result.constraints?.maxTaskRetryCount, TASK_UPDATE_OPTIONS.constraints.maxTaskRetryCount);

    });

    it("should add a task with an application package reference successfully", async () => {
      const task = {
        id: TASK_APPPACK_NAME,
        commandLine: "cmd /c echo hello world",
        applicationPackageReferences: [
          {
            applicationId: "my_application_id"
          }
        ]
      };
      try {
        const result1 = await client.task.add(JOB_NAME, task);
        const result2 = await client.task.get(JOB_NAME, TASK_APPPACK_NAME);
        assert.isDefined(result2.applicationPackageReferences);
      }
      catch (error) {
        console.log(error)
      }

    });

    it("should create a task with authentication token settings successfully", async () => {
      const jobId = JOB_NAME;
      const taskId = "TaskWithAuthTokenSettings";
      const task: Task = {
        id: taskId,
        commandLine: "cmd /c echo Hello World",
        authenticationTokenSettings: {
          access: ["job"]
        }
      };

      const result = await client.task.add(jobId, task);

      const result2 = await client.task.get(jobId, taskId);

      assert.isDefined(result2.authenticationTokenSettings);
      assert.isDefined(result2.authenticationTokenSettings!.access);
      assert.lengthOf(result2.authenticationTokenSettings!.access!, 1);
      assert.equal(result2.authenticationTokenSettings!.access![0], "job");
    });

    it.skip("should create a task with a user identity successfully", async () => {
      const jobId = JOB_NAME;
      const taskId = "TaskWithUserIdentity";
      const task = {
        id: taskId,
        // This command should return a non-zero exit code for a non-admin user
        commandLine: "cmd /c net session >nul 2>&1",
        userIdentity: {
          userName: nonAdminPoolUser
        }
      };

      await client.task.add(jobId, task);

      let result2: TaskGetResponse;
      while (true) {
        result2 = await client.task.get(jobId, taskId);
        if (result2.executionInfo !== undefined && result2.executionInfo.result != undefined) {
          break;
        } else {
          await wait(POLLING_INTERVAL * 2);
        }
      }
      assert.isDefined(result2.userIdentity);
      assert.equal(result2.userIdentity!.userName, nonAdminPoolUser);
      assert.isDefined(result2.executionInfo);
      assert.equal(result2.executionInfo!.result, "failure");
      assert.notEqual(result2.executionInfo!.exitCode, 0);
    }).timeout(LONG_TEST_TIMEOUT);

    it("should count tasks sucessfully", async () => {
      const jobId = JOB_NAME;
      const result = await client.job.getTaskCounts(jobId);

      assert.isDefined(result.taskCounts.active);
      assert.isDefined(result.taskCounts.completed);
    });

    //TODO: Need to test with actual subtasks
    // it("should list sub tasks successfully", async () => {
    //   const result = await client.task.listSubtasks(JOB_NAME, TASK_NAME);

    //   assert.equal(result._response.status, 200);
    // });

  });

  describe("File operations", async () => {
    it("should list files from task successfully", async () => {
      try {
        let result: TaskGetResponse;
        while (true) {
          result = await client.task.get(JOB_NAME, TASK2_NAME);
          if (result.executionInfo !== undefined && result.executionInfo.result != undefined) {
            break;
          } else {
            await wait(POLLING_INTERVAL * 2);
          }
        }

        const result2 = await client.file.listFromTask(JOB_NAME, TASK2_NAME);
        var fileCount = await getListPagedCount(result2);
        assert.isAtLeast(fileCount, 1);
      }
      catch (error) {
        console.log(error);
        throw error;
      }

      //assert.equal(result._response.status, 200);
    });

    it("should get file properties from task successfully", async () => {
      try {
        const result = await client.file.getPropertiesFromTask(JOB_NAME, TASK2_NAME, "stderr.txt");
      }
      catch (error) {
        console.log(error);
        throw error;
      }


      //assert.equal(result._response.status, 200);
    });

    // it("should get file from task successfully", (done) => {
    //   client.file
    //     .getFromTask(JOB_NAME, TASK2_NAME, "stdout.txt")
    //     .then((result) => {
    //       //assert.equal(result._response.status, 200);
    //       readStreamToBuffer(result.readableStreamBody!, function (_err, buff) {
    //         assert.isAtLeast(buff.length, 1);
    //         done();
    //       });
    //     })
    //     .catch((error) => {
    //       assert.fail(error);
    //     });
    // });

    it("should delete file from task successfully", async () => {
      try {
        const result = await client.file.deleteFromTask(JOB_NAME, TASK2_NAME, "stderr.txt");
      }
      catch (error) {
        console.log(error);
        throw error;
      }


      //assert.equal(result._response.status, 200);
    });

    it("should re-list compute nodes successfully", async () => {
      const result = await client.computeNode.list(BASIC_POOL);

      let nodeList = [];

      for await (const obj of result) {
        nodeList.push(obj);
      }

      assert.isAtLeast(nodeList.length, 1);

      compute_nodes = nodeList.map(function (x) {
        return x.id!;
      });
      //wait(100000);
      // if (!suite.isPlayback) {
      //   console.log('Waiting for nodes to be ready...')
      //   setTimeout(function () {
      //     done();
      //   }, 100000);
      // } else {
      //   done();
      // }
    });

    it("should list files from compute node successfully", async () => {
      try {
        let computeNodeToQuery = compute_nodes[1];
        let computeNodeStatusResult;
        while (true) {
          computeNodeStatusResult = await client.computeNode.get(BASIC_POOL, computeNodeToQuery)
          if (computeNodeStatusResult.state === "idle") {
            break;
          } else {
            await wait(POLLING_INTERVAL * 2);
          }
        }
        const result = await client.file.listFromComputeNode(BASIC_POOL, computeNodeToQuery);
        const fileList = await getListObj(result);
        assert.isAtLeast(fileList.length, 1);
      }
      catch (exception) {
        console.log(exception);
        throw exception;
      }
      //assert.equal(result._response.status, 200);
    }).timeout(LONG_TEST_TIMEOUT);

    it("should get file properties from node successfully", async () => {
      try {
        const result = await client.file.getPropertiesFromComputeNode(
          BASIC_POOL,
          compute_nodes[1],
          "startup/wd/hello.txt"
        );
      }
      catch (exception) {
        console.log(exception);
        throw exception;
      }


      //assert.equal(result._response.status, 200);
    });

    // it("should get file from node successfully", (done) => {
    //   client.file
    //     .getFromComputeNode(BASIC_POOL, computeNodes[1], "startup/wd/hello.txt")
    //     .then((result) => {
    //       //assert.equal(result._response.status, 200);
    //       readStreamToBuffer(result.readableStreamBody!, function (_err, buff) {
    //         assert.isAtLeast(buff.length, 1);
    //         done();
    //       });
    //     })
    //     .catch((error) => {
    //       assert.fail(error);
    //     });
    // });

    it("should delete file from node successfully", async () => {
      try {
        const result = await client.file.deleteFromComputeNode(
          BASIC_POOL,
          compute_nodes[1],
          "startup/wd/hello.txt"
        );
      }
      catch (exception) {
        console.log(exception);
        throw exception;
      }


      //assert.equal(result._response.status, 200);
    });
  });

  // describe("Compute node operations", async () => {
  //   it("should list compute nodes successfully", async () => {
  //     let listResult;
  //     let nodeCounter = 0;
  //     let singleNode;
  //     listResult = await client.computeNode.list(BASIC_POOL);

  //     for await (const node of listResult) {
  //       nodeCounter += 1;
  //     }

  //     assert.equal(nodeCounter, BASIC_POOL_NUM_VMS);

  //     let nodesProvisioning: Boolean = true;
  //     while (nodesProvisioning) {
  //       listResult = await client.computeNode.list(BASIC_POOL);
  //       for await (const node of listResult) {
  //         if (node.state === "starting") {
  //           await wait(POLLING_INTERVAL);
  //           break;
  //         }
  //         else {
  //           compute_nodes.push(node.id!);
  //           nodesProvisioning = false;
  //           assert.equal(node.state, "idle");
  //           assert.equal(node.schedulingState, "enabled");
  //           assert.isTrue(node.isDedicated);
  //           break;
  //         }
  //       }

  //     }

  //   }).timeout(LONG_TEST_TIMEOUT);

  //   it("should get a compute node reference", async () => {
  //     const result = await client.computeNode.get(BASIC_POOL, compute_nodes[0]);
  //     assert.equal(result.id, compute_nodes[0]);
  //     assert.equal(result.state, "idle");
  //     assert.equal(result.schedulingState, "enabled");
  //     assert.equal(result._response.status, 200);
  //   });

  //   it("should get a compute node reference", async () => {
  //     const result = await client.computeNode.get(BASIC_POOL, compute_nodes[0]);

  //     assert.equal(result.id, compute_nodes[0]);
  //     assert.equal(result.state, "idle");
  //     assert.equal(result.schedulingState, "enabled");
  //     assert.equal(result._response.status, 200);
  //   });

  //   it("should add a user to a compute node successfully", async () => {
  //     const options = { name: TEST_USER, isAdmin: false, password: "kt#_gahr!@aGERDXA" };
  //     const result = await client.computeNode.addUser(BASIC_POOL, compute_nodes[0], options);

  //     assert.equal(result._response.status, 201);
  //   });

  //   it("should update a compute node user successfully", async () => {
  //     const options = { password: "liilef#$DdRGSa_ewkjh" };
  //     const result = await client.computeNode.updateUser(
  //       BASIC_POOL,
  //       compute_nodes[0],
  //       TEST_USER,
  //       options
  //     );

  //     assert.equal(result._response.status, 200);
  //   });

  //   it("should get a remote desktop file successfully", (done) => {
  //     client.computeNode
  //       .getRemoteDesktop(BASIC_POOL, compute_nodes[0])
  //       .then((result) => {
  //         assert.equal(result._response.status, 200);
  //         readStreamToBuffer(result.readableStreamBody!, function (_err, buff) {
  //           assert.isAtLeast(buff.length, 1);
  //           done();
  //         });
  //       })
  //       .catch((error) => {
  //         assert.fail(error);
  //       });
  //   });

  //   it("should delete a compute node user successfully", async () => {
  //     const result = await client.computeNode.deleteUser(BASIC_POOL, compute_nodes[0], TEST_USER);

  //     assert.equal(result._response.status, 200);
  //   });

  //   it("should disable scheduling on a compute node successfully", async () => {
  //     while (true) {
  //       try {
  //         const result = await client.computeNode.disableScheduling(BASIC_POOL, compute_nodes[1]);
  //         assert.equal(result._response.status, 200);
  //         break;
  //       } catch (e: any) {
  //         if (e.code === "NodeNotReady") {
  //           await wait(POLLING_INTERVAL);
  //         } else {
  //           throw e;
  //         }
  //       }
  //     }
  //   });

  //   it("should enable scheduling on a compute node successfully", async () => {
  //     const result = await client.computeNode.enableScheduling(BASIC_POOL, compute_nodes[1]);

  //     assert.equal(result._response.status, 200);
  //   });

  //   it("should reboot a compute node successfully", async () => {
  //     const result = await client.computeNode.reboot(BASIC_POOL, compute_nodes[0]);

  //     assert.equal(result._response.status, 202);
  //   });

  //   it("should reimage a compute node successfully", async () => {
  //     const result = await client.computeNode.reimage(BASIC_POOL, compute_nodes[1]);

  //     assert.equal(result._response.status, 202);
  //   });

  //   it("should upload pool node logs at paas pool", async () => {
  //     const container = "https://teststorage.blob.core.windows.net/fakecontainer";
  //     const config: BatchServiceModels.UploadBatchServiceLogsConfiguration = {
  //       containerUrl: container,
  //       startTime: new Date("2018-02-25T00:00:00.00")
  //     };
  //     const result = await client.computeNode.uploadBatchServiceLogs(
  //       BASIC_POOL,
  //       compute_nodes[2],
  //       config
  //     );

  //     assert.equal(result._response.status, 200);
  //     assert.isAtLeast(result.numberOfFilesUploaded, 1);
  //   });
  // });

  describe("Autoscale operations", async () => {
    it("should enable autoscale successfully", async () => {
      const model: BatchServiceModels.PoolEnableAutoScaleParameter = {
        autoScaleFormula: "$TargetDedicatedNodes=2",
        autoScaleEvaluationInterval: duration({ minutes: 6 }).toISOString()
      };

      const result = await client.pool.enableAutoScale(BASIC_POOL, model);

      assert.equal(result._response.status, 200);
    });

    it("should evaluate pool autoscale successfully", async () => {
      const result = await client.pool.evaluateAutoScale(BASIC_POOL, "$TargetDedicatedNodes=3");

      assert.equal(
        result.results,
        "$TargetDedicatedNodes=3;$TargetLowPriorityNodes=0;$NodeDeallocationOption=requeue"
      );
      assert.equal(result._response.status, 200);
    });

    it("should fail to evaluate invalid autoscale formula", async () => {
      const result = await client.pool.evaluateAutoScale(BASIC_POOL, "something_useless");

      assert.equal(
        result.results,
        "$TargetDedicatedNodes=2;$TargetLowPriorityNodes=0;$NodeDeallocationOption=requeue"
      );
      assert.equal(result._response.status, 200);
    });

    it("should disable autoscale successfully", async () => {
      const result = await client.pool.disableAutoScale(BASIC_POOL);

      assert.equal(result._response.status, 200);
    });
  });

  describe("Task cleanup", async () => {
    it("should delete a task successfully", async () => {
      const result = await client.task.delete(JOB_NAME, TASK_NAME);
    });

    it("should add a task with an application package reference successfully", async () => {
      const taskId = "ApplicationPacakgeReferenceTask";
      const task = {
        id: taskId,
        commandLine: "cmd /c echo hello world",
        applicationPackageReferences: [
          {
            applicationId: "my_application_id"
          }
        ]
      };
      const result1 = await client.task.add(JOB_NAME, task);

      const result2 = await client.task.get(JOB_NAME, taskId);
      assert.isDefined(result2.applicationPackageReferences);
    });

    it("should delete a second task successfully", async () => {
      try {
        const result = await client.task.delete(JOB_NAME, TASK2_NAME);
      }
      catch (error) {
        console.log(error);
      }

    });
  });

  describe("Job operations (advanced)", async () => {
    it("should get a job reference successfully", async () => {
      const result = await client.job.get(JOB_NAME);

      assert.equal(result.id, JOB_NAME);
      assert.equal(result.state, "active");
      assert.equal(result.poolInfo!.poolId, BASIC_POOL);
      //assert.equal(result._response.status, 200);
    });

    it("should list jobs successfully", async () => {
      const result = await client.job.list();
      const jobCount = await getListPagedCount(result);
      assert.isAtLeast(jobCount, 1);
      //assert.equal(result._response.status, 200);
    });

    it("should fail to job prep+release status", async () => {
      try {
        const result = await client.job.listPreparationAndReleaseTaskStatus(JOB_NAME).next();
        assert.fail("Expected error to be thrown");
      } catch (error) {
        assert.equal(error.code, "JobPreparationTaskOrReleaseTaskNotSpecified");
      }
    });

    it("should disable a job successfully", async () => {
      const result = await client.job.disable(JOB_NAME, { disableTasks: "requeue" });

      //assert.equal(result._response.status, 202);
    });

    it("should enable a job successfully", async () => {
      const result = await client.job.enable(JOB_NAME);

      //assert.equal(result._response.status, 202);
    });

    it("should terminate a job successfully", async () => {
      const result = await client.job.terminate(JOB_NAME);

      //assert.equal(result._response.status, 202);
    });

    it("should delete a job successfully", async function () {
      const result = await client.job.delete(JOB_NAME);

      //assert.equal(result._response.status, 202);
    })

    it("should get all job statistics successfully", async () => {
      const result = await client.job.getAllLifetimeStatistics();

      assert.isDefined(result.userCPUTime);
      assert.isDefined(result.kernelCPUTime);
      //assert.equal(result._response.status, 200);
    });
  });

  describe("Job schedules", async () => {
    it("should create a job schedule successfully", async () => {
      const options: JobSchedule = {
        id: SCHEDULE,
        jobSpecification: {
          displayName: JOB_NAME,
          poolInfo: { poolId: BASIC_POOL }
        },
        schedule: {
          doNotRunUntil: moment().add(3, "days").toDate(),
          startWindow: duration({ minutes: 6 }).toISOString()
        }
      };

      const result = await client.jobSchedule.add(options);

      //assert.equal(result._response.status, 201);
    });

    it("should list job schedules successfully", async () => {
      const result = await client.jobSchedule.list();
      const jobScheduleCount = await getListPagedCount(result);
      assert.equal(jobScheduleCount, 1);
    });

    it("should list jobs from job schedule successfully", async () => {
      const result = await client.job.listFromJobSchedule(SCHEDULE);
      const jobCount = await getListPagedCount(result);
      assert.equal(jobCount, 0);
    });

    it("should check if a job schedule exists successfully", async () => {
      const result = await client.jobSchedule.exists(SCHEDULE);
    });

    it("should get a job schedule reference successfully", async () => {
      const result = await client.jobSchedule.get(SCHEDULE);

      assert.equal(result.id, SCHEDULE);
      assert.equal(result.state, "active");
      assert.equal(result.jobSpecification?.displayName, JOB_NAME);
    });

    it("should update a job schedule successfully", async () => {
      const options: JobSchedule = {
        schedule: { recurrenceInterval: duration({ hours: 6 }).toISOString() },
        jobSpecification: { poolInfo: { poolId: ADVANCED_POOL } }
      };

      const result = await client.jobSchedule.update(SCHEDULE, options);

      //assert.equal(result._response.status, 200);
    });

    it("should patch a job schedule successfully", async () => {
      const options = {
        schedule: {
          recurrenceInterval: duration({ hours: 3 }).toISOString(),
          startWindow: duration({ hours: 1 }).toISOString()
        }
      };

      const result = await client.jobSchedule.patch(SCHEDULE, options);

      //assert.equal(result._response.status, 200);
    });

    it("should disable a job schedule successfully", async () => {
      const result = await client.jobSchedule.disable(SCHEDULE);

      //assert.equal(result._response.status, 204);
    });

    it("should enable a job schedule successfully", async () => {
      const result = await client.jobSchedule.enable(SCHEDULE);

      //assert.equal(result._response.status, 204);
    });

    it("should terminate a job schedule successfully", async () => {
      const result = await client.jobSchedule.terminate(SCHEDULE);

      // assert.equal(result._response.status, 202);
    });

    it("should delete a job schedule successfully", async () => {
      const result = await client.jobSchedule.delete(SCHEDULE);

      // assert.equal(result._response.status, 202);
    });
  });

  describe("Resource cleanup", () => {
    it("should remove nodes in pool successfully", async () => {
      const options: NodeRemoveParameter = {
        nodeList: compute_nodes,
        nodeDeallocationOption: "terminate"
      };
      const result = await client.pool.removeNodes(BASIC_POOL, options);

      //assert.equal(result._response.status, 202);
    });

    it("should delete a pool successfully", async function () {
      await client.pool.delete(BASIC_POOL);
    });

    it("should fail to delete a non-existent pool", async () => {
      try {
        await client.pool.delete(BASIC_POOL);
      } catch (error: any) {
        assert.equal(error.code, "PoolBeingDeleted");
      }
    });

    it("should delete the endpoint pool successfully", async () => {
      const result = await client.pool.delete(ENDPOINT_POOL);

      //assert.equal(result._response.status, 202);
    });

    it("should delete a certificate successfully", async function () {
      const result = await client.certificate.delete("sha1", certThumb);
    })
  })




})
