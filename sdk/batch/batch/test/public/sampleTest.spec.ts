/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import {
  env,
  Recorder,
  delay,
  isPlaybackMode,
  RecorderStartOptions
} from "@azure-tools/test-recorder";
import { v4 as uuid } from "uuid";
import { createClient } from "./utils/recordedClient"
import { assert } from "chai";
import { BatchServiceClient, BatchServiceClientOptions } from "../../src/batchServiceClient";
import { wait } from "./utils/wait";
import { Pool, Certificate, PoolGetOptionalParams, PoolUpdate, JobSchedule, BatchJob, BatchTask, TaskGetResponse, NodeRemoveParameters, PoolEnableAutoScaleParameters, UploadBatchServiceLogsConfiguration } from "../../src/generated/models";
import { duration } from "moment";
import moment from "moment";
import { PagedAsyncIterableIterator } from "@azure/core-paging";
import { errorMonitor } from "events";
import { pool } from "../../src/generated/models/parameters";

const _SUFFIX = Math.random()
  .toString(16)
  .substr(2, 4);

async function getListObj(objIterator: PagedAsyncIterableIterator<any>): Promise<Array<any>> {
  let objList = [];

  for await (const obj of objIterator) {
    objList.push(obj);
  }

  return objList;

}


function getPoolName(type: string) {
  return `testjssdk-${type}-${_SUFFIX}`;
}

const ENDPOINT_POOL = getPoolName("endpoint");
const BASIC_POOL = getPoolName("basic");
const TEST_POOL3 = getPoolName("3");
const VNET_POOL = getPoolName("vnet");
const IMAGE_POOL = getPoolName("image");
const DISK_POOL = getPoolName("datadisk");
const ADVANCED_POOL = getPoolName("Advanced");
const BASIC_POOL_NUM_VMS = 4;
const JOB_NAME = `JSSDKTestJob-${_SUFFIX}`;
const TASK_NAME = `${JOB_NAME}-task1`;
const TASK_UPDATE_OPTIONS = {
  constraints: { maxTaskRetryCount: 3 }
};
const TASK2_NAME = `${JOB_NAME}-task2`;
const SCHEDULE = "JSSDKTestSchedule";
const TEST_USER = "JSSDKTestSchedule";
const VMSIZE_A1 = "Standard_A1_v2";
const VMSIZE_D1 = "Standard_D1_v2";
const VMSIZE_SMALL = "Small";

const POLLING_INTERVAL = 5000;
const LONG_TEST_TIMEOUT = 1000000;

describe("Batch Service Test", () => {
  let recorder: Recorder;
  let batchClient: BatchServiceClient;

  let certThumb: string = "cff2ab63c8c955aaf71989efa641b906558d9fb7";
  let nonAdminPoolUser: string = "nonAdminUser";
  let computeNodes: string[];

  const readStreamToBuffer = function (
    strm: NodeJS.ReadableStream,
    callback: (_a: any, buf: Buffer) => void
  ) {
    const bufs: any[] = [];
    strm.on("data", function (d) {
      bufs.push(d);
    });
    strm.on("end", function () {
      callback(null, Buffer.concat(bufs));
    });
  };

  beforeEach(async function () {
    ({ batchClient, recorder } = await createClient(this.currentTest, "AAD"));

  });

  afterEach(async function () {
    await recorder.stop();
  });

  describe("Certificate operations", () => {
    it("should list supported images successfully", async () => {
      const supportedImages = await batchClient.account.listSupportedImages();

      for await (const image of supportedImages) {
        assert.isNotNull(image.nodeAgentSKUId);
        assert.isNotNull(image.osType);

      }

    });

    it.only("should add new certificate successfully", async () => {
      const cert: Certificate = {
        thumbprint: certThumb,
        thumbprintAlgorithm: "sha1",
        password: "nodesdk",
        certificateFormat: "pfx",
        data:
          "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"
      };

      await batchClient.certificate.add(cert);
    });

    it("should list certificates successfully", async () => {
      const result = await batchClient.certificate.list();
      let certCounter = 0;
      for await (const cert of result) {
        assert.equal(cert.thumbprint, certThumb);
        assert.equal(cert.thumbprintAlgorithm, "sha1");
        ++certCounter;
      }

      assert.isAtLeast(certCounter, 1);

    });

    it("should get certificate reference successfully", async () => {
      const result = await batchClient.certificate.get("sha1", certThumb);
      assert.equal(result.thumbprint, certThumb);
      assert.equal(result.thumbprintAlgorithm, "sha1");
    });

  })

  // describe.skip("Authentication", () => {
  //   it("Should perform AAD authentication successfully.", async function () {
  //     const aadClient = await createClient("AAD", recorder);
  //     const supportedImages = aadClient.account.listSupportedImages();

  //     for await (const image of supportedImages) {
  //       assert.isNotNull(image.nodeAgentSKUId);
  //       assert.isNotNull(image.osType);

  //     }
  //   })
  // })

  describe("Basic Pool operations", () => {
    it.only("Create Batch Pool successfully", async function () {
      // Use assert to test your assumptions

      const poolParams: Pool = {
        id: recorder.variable("BASIC_POOL", BASIC_POOL),
        vmSize: VMSIZE_D1,
        cloudServiceConfiguration: { osFamily: "4" },
        targetDedicatedNodes: BASIC_POOL_NUM_VMS,
        certificateReferences: [{ thumbprint: certThumb, thumbprintAlgorithm: "sha1" }],
        // Ensures there's a compute node file we can reference later
        startTask: { commandLine: "cmd /c echo hello > hello.txt" },
        // Sets up pool user we can reference later
        userAccounts: [
          {
            name: nonAdminPoolUser,
            password: recorder.variable("POOL_USER_ACCOUNT_PASSWORD", "dummyPlaceHolderPassword"),
            elevationLevel: "nonadmin"
          }
        ]
      }

      try {
        const result = await batchClient.pool.add(poolParams);
      }
      catch (error) {
        console.log(error);
        throw error;
      }

      await wait(20000);


    });

    it("should patch pool parameters successfully", async () => {
      const options: PoolUpdate = {
        metadata: [
          {
            name: "foo2",
            value: "bar2"
          }
        ]
      };

      const poolId = recorder.variable("BASIC_POOL", BASIC_POOL);
      try {
        await batchClient.pool.patch(poolId, options);
        const result = await batchClient.pool.get(poolId);
        assert.equal(result.id, poolId);
        assert.equal(result.state, "active");

        for (let index = 0; index < options.metadata!.length; index++) {
          assert.equal(result.metadata![index].name, options.metadata![index].name);
          assert.equal(result.metadata![index].value, options.metadata![index].value);
        }
      }
      catch (error) {
        console.log(error);
        throw error;
      }


    });

    it("should get a pool reference successfully", async () => {
      let result: any;
      let metadata: any;
      const poolId = recorder.variable("BASIC_POOL", BASIC_POOL);

      const promise = new Promise<void>((resolve) => {
        const timeout = setInterval(async () => {
          result = await batchClient.pool.get(poolId);
          metadata = result.metadata![0];
          if (result.allocationState === "steady") {
            resolve();
            clearTimeout(timeout);
          }
        }, POLLING_INTERVAL);
      });

      await promise;

      assert.equal(result.id, poolId);
      assert.equal(result.state, "active");
      assert.equal(result.allocationState, "steady");
      assert.isDefined(result.cloudServiceConfiguration);
      assert.equal(result.cloudServiceConfiguration!.osFamily, "4");
      assert.equal(result.vmSize.toLowerCase(), VMSIZE_D1.toLowerCase());

      assert.equal(metadata.name, "foo2");
      assert.equal(metadata.value, "bar2");

      assert.isDefined(result.startTask);
      assert.equal(result.startTask!.commandLine, "cmd /c echo hello > hello.txt");

      assert.lengthOf(result.userAccounts!, 1);
      assert.equal(result.userAccounts![0].name, nonAdminPoolUser);
      assert.equal(result.userAccounts![0].elevationLevel, "nonadmin");
    }).timeout(LONG_TEST_TIMEOUT);

    it("Get Batch Pool Info", async function () {
      // Use assert to test your assumptions
      const poolId = recorder.variable("BASIC_POOL", BASIC_POOL);
      const result = await batchClient.pool.get(poolId)

      assert.equal(result.id, poolId);
      assert.equal(result.state, "active");
      assert.isDefined(result.cloudServiceConfiguration);
      assert.equal(result.targetDedicatedNodes, BASIC_POOL_NUM_VMS);
      assert.isFalse(result.enableAutoScale);
      assert.oneOf(result.allocationState, ["resizing", "steady"])

    });

    it("should update pool parameters successfully", async () => {
      const options: Pool = {
        metadata: [{ name: "foo", value: "bar" }],
        certificateReferences: [],
        applicationPackageReferences: [],
        // Ensures the start task isn't cleared
        startTask: { commandLine: "cmd /c echo hello > hello.txt" }
      };

      const result = await batchClient.pool.updateProperties(recorder.variable("BASIC_POOL", BASIC_POOL), options);
    });

    it("should get a pool reference with odata successfully", async () => {
      const options: PoolGetOptionalParams = {
        poolGetOptions: { select: "id,state", expand: "stats" }
      };

      const poolId = recorder.variable("BASIC_POOL", BASIC_POOL);

      const result = await batchClient.pool.get(poolId, options);
      assert.equal(result.id, poolId);
      assert.equal(result.state, "active");
      assert.isUndefined(result.allocationState);
      assert.isUndefined(result.vmSize);
    });

    it("should add a pool with vnet and get expected error", async () => {
      const pool: Pool = {
        id: recorder.variable("VNET_POOL", VNET_POOL),
        vmSize: VMSIZE_A1,
        cloudServiceConfiguration: { osFamily: "4" },
        targetDedicatedNodes: 0,
        networkConfiguration: {
          subnetId:
            "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/test/providers/Microsoft.Network/virtualNetworks/vnet1/subnets/subnet1"
        }
      };

      try {
        await batchClient.pool.add(pool);
        assert.fail("Expected error to be thrown");
      } catch (error: any) {
        assert.equal(error.statusCode, 403);
        assert.equal(error.details.code, "Forbidden");
      }
    });

    it("should add a pool with a custom image and get expected error", async () => {
      const pool: Pool = {
        id: recorder.variable("IMAGE_POOL", IMAGE_POOL),
        vmSize: VMSIZE_A1,
        virtualMachineConfiguration: {
          imageReference: {
            virtualMachineImageId:
              "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/test/providers/Microsoft.Compute/images/FakeImage"
          },
          nodeAgentSKUId: "batch.node.ubuntu 16.04"
        },
        targetDedicatedNodes: 0
      };

      try {
        await batchClient.pool.add(pool);
        assert.fail("Expected error to be thrown");
      } catch (error: any) {
        assert.equal(error.statusCode, 400);
        assert.equal(error.details.code, "InvalidPropertyValue");
        assert.equal(error.details.values[0].value, "virtualMachineImageId");
      }
    });

    it("should add a pool with a Data Disk", async () => {
      const pool: Pool = {
        id: recorder.variable("DISK_POOL", DISK_POOL),
        vmSize: VMSIZE_A1,
        virtualMachineConfiguration: {
          imageReference: {
            publisher: "Canonical",
            offer: "UbuntuServer",
            sku: "18.04-LTS"
          },
          nodeAgentSKUId: "batch.node.ubuntu 18.04",
          dataDisks: [
            {
              lun: 1,
              diskSizeGB: 50
            }
          ]
        },
        targetDedicatedNodes: 0
      };

      const resultAdd = await batchClient.pool.add(pool);

      await wait(POLLING_INTERVAL);

      const resultGet = await batchClient.pool.get(pool.id!);
      assert.equal(resultGet.virtualMachineConfiguration!.dataDisks![0].lun, 1);
      assert.equal(resultGet.virtualMachineConfiguration!.dataDisks![0].diskSizeGB, 50);

      const resultDelete = await batchClient.pool.delete(pool.id!);
    });

  })

  describe("Pool with endpoint configuration", async () => {
    it("should add a pool with inbound endpoint configuration successfully", async () => {
      const pool: Pool = {
        id: recorder.variable("ENDPOINT_POOL", ENDPOINT_POOL),
        vmSize: VMSIZE_A1,
        networkConfiguration: {
          endpointConfiguration: {
            inboundNATPools: [
              {
                name: "TestEndpointConfig",
                protocol: "udp",
                backendPort: 64444,
                frontendPortRangeStart: 60000,
                frontendPortRangeEnd: 61000,
                networkSecurityGroupRules: [
                  {
                    priority: 150,
                    access: "allow",
                    sourceAddressPrefix: "*"
                  }
                ]
              }
            ]
          }
        },
        virtualMachineConfiguration: {
          nodeAgentSKUId: "batch.node.ubuntu 18.04",
          imageReference: {
            publisher: "Canonical",
            offer: "UbuntuServer",
            sku: "18.04-LTS"
          }
        },
        targetDedicatedNodes: 1
      };

      const result = await batchClient.pool.add(pool);

      //assert.equal(result._response.status, 201);
    });

    it("should get the details of a pool with endpoint configuration successfully", async () => {
      let result;
      const poolId = recorder.variable("ENDPOINT_POOL", ENDPOINT_POOL)
      while (true) {
        let listResult = await batchClient.computeNode.list(poolId);
        result = await getListObj(listResult)
        if (result.length > 0) {
          break;
        } else {
          await wait(POLLING_INTERVAL);
        }
      }
      assert.lengthOf(result, 1);
      assert.isDefined(result[0].endpointConfiguration);
      assert.lengthOf(result[0].endpointConfiguration!.inboundEndpoints, 2);
      assert.equal(
        result[0].endpointConfiguration!.inboundEndpoints[0].name,
        "TestEndpointConfig.0"
      );
      assert.equal(result[0].endpointConfiguration!.inboundEndpoints[0].protocol, "udp");
    });

    it("should get pool node counts successfully", async () => {
      let result;
      let endpointPool;
      const poolId = recorder.variable("ENDPOINT_POOL", ENDPOINT_POOL);
      while (true) {
        let listResult = await batchClient.account.listPoolNodeCounts();
        result = await getListObj(listResult);
        if (result.length > 0) {
          endpointPool = result.filter(pool => pool.poolId == poolId);
          if (endpointPool.length > 0 && endpointPool[0].dedicated!.idle > 0) {
            break;
          }
        } else {
          await wait(POLLING_INTERVAL);
        }
      }

      //assert.equal(result._response.status, 200);

      // const endpointPoolObj = result.filter(pool => pool.poolId == ENDPOINT_POOL);

      // assert.isAbove(endpointPoolObj.length, 0, `Pool with Pool Id ${ENDPOINT_POOL} not found`);

      // assert.equal(endpointPoolObj[0].dedicated!.idle, 1);
      assert.equal(endpointPool[0].lowPriority!.total, 0);

    }).timeout(LONG_TEST_TIMEOUT);
  });

  describe("Compute node operations", async () => {
    it("should list compute nodes successfully", async () => {
      let listResult;
      let nodeCounter = 0;
      let singleNode;
      const poolId = recorder.variable("BASIC_POOL", BASIC_POOL);
      listResult = await batchClient.computeNode.list(poolId);

      for await (const node of listResult) {
        nodeCounter += 1;
      }

      assert.equal(nodeCounter, BASIC_POOL_NUM_VMS);

      let nodesProvisioning: Boolean = true;
      while (nodesProvisioning) {
        listResult = await batchClient.computeNode.list(poolId);
        for await (const node of listResult) {
          if (node.state === "starting" || node.state == "waitingforstarttask") {
            await wait(POLLING_INTERVAL);
            break;
          }
          else {
            nodesProvisioning = false;
            listResult = await batchClient.computeNode.list(poolId);
            const nodeList = await getListObj(listResult);
            computeNodes = nodeList.map(function (x) {
              return x.id!;
            });
            assert.equal(node.state, "idle");
            assert.equal(node.schedulingState, "enabled");
            assert.isTrue(node.isDedicated);
            break;
          }
        }

      }

    }).timeout(LONG_TEST_TIMEOUT);

    it("should get a compute node reference", async () => {
      const result = await batchClient.computeNode.get(recorder.variable("BASIC_POOL", BASIC_POOL), computeNodes[0]);
      assert.equal(result.id, computeNodes[0]);
      assert.equal(result.state, "idle");
      assert.equal(result.schedulingState, "enabled");
      //assert.equal(result._response.status, 200);
    });

    it("should add a user to a compute node successfully", async () => {
      const options = { name: TEST_USER, isAdmin: false, password: "kt#_gahr!@aGERDXA" };
      const result = await batchClient.computeNode.addUser(recorder.variable("BASIC_POOL", BASIC_POOL), computeNodes[0], options);

      //assert.equal(result._response.status, 201);
    });

    it("should update a compute node user successfully", async () => {
      const options = { password: "liilef#$DdRGSa_ewkjh" };
      const result = await batchClient.computeNode.updateUser(
        recorder.variable("BASIC_POOL", BASIC_POOL),
        computeNodes[0],
        TEST_USER,
        options
      );

      //assert.equal(result._response.status, 200);
    });

    it("should get a remote desktop file successfully", (done) => {
      batchClient.computeNode
        .getRemoteDesktop(recorder.variable("BASIC_POOL", BASIC_POOL), computeNodes[0])
        .then((result) => {
          //assert.equal(result._response.status, 200);
          readStreamToBuffer(result.readableStreamBody!, function (_err, buff) {
            assert.isAtLeast(buff.length, 1);
            done();
          });
        })
        .catch((error) => {
          assert.fail(error);
        });
    });

    it("should delete a compute node user successfully", async () => {
      const result = await batchClient.computeNode.deleteUser(recorder.variable("BASIC_POOL", BASIC_POOL), computeNodes[0], TEST_USER);

      //assert.equal(result._response.status, 200);
    });

    it("should disable scheduling on a compute node successfully", async () => {
      while (true) {
        try {
          const result = await batchClient.computeNode.disableScheduling(recorder.variable("BASIC_POOL", BASIC_POOL), computeNodes[1]);
          //assert.equal(result._response.status, 200);
          break;
        } catch (e: any) {
          if (e.code === "NodeNotReady") {
            await wait(POLLING_INTERVAL);
          } else {
            throw e;
          }
        }
      }
    });

    it("should enable scheduling on a compute node successfully", async () => {
      const result = await batchClient.computeNode.enableScheduling(recorder.variable("BASIC_POOL", BASIC_POOL), computeNodes[1]);

      //assert.equal(result._response.status, 200);
    });

    it("should reboot a compute node successfully", async () => {
      const result = await batchClient.computeNode.reboot(recorder.variable("BASIC_POOL", BASIC_POOL), computeNodes[0]);

      //assert.equal(result._response.status, 202);
    });

    it("should reimage a compute node successfully", async () => {
      const result = await batchClient.computeNode.reimage(recorder.variable("BASIC_POOL", BASIC_POOL), computeNodes[1]);

      //assert.equal(result._response.status, 202);
    });

    it("should upload pool node logs at paas pool", async () => {
      const container = "https://teststorage.blob.core.windows.net/fakecontainer";
      const config: UploadBatchServiceLogsConfiguration = {
        containerUrl: container,
        startTime: new Date("2018-02-25T00:00:00.00")
      };
      const result = await batchClient.computeNode.uploadBatchServiceLogs(
        recorder.variable("BASIC_POOL", BASIC_POOL),
        computeNodes[2],
        config
      );

      //assert.equal(result._response.status, 200);
      assert.isAtLeast(result.numberOfFilesUploaded, 1);
    });
  });

  describe.skip("Autoscale operations", async () => {
    it("should enable autoscale successfully", async () => {
      const model: PoolEnableAutoScaleParameters = {
        autoScaleFormula: "$TargetDedicatedNodes=2",
        autoScaleEvaluationInterval: duration({ minutes: 6 }).toISOString()
      };

      const result = await batchClient.pool.enableAutoScale(recorder.variable("BASIC_POOL", BASIC_POOL), model);

      //assert.equal(result._response.status, 200);
    });

    it("should evaluate pool autoscale successfully", async () => {
      const result = await batchClient.pool.evaluateAutoScale(recorder.variable("BASIC_POOL", BASIC_POOL), { autoScaleFormula: "$TargetDedicatedNodes=3" });

      assert.equal(
        result.results,
        "$TargetDedicatedNodes=3;$TargetLowPriorityNodes=0;$NodeDeallocationOption=requeue"
      );
      //assert.equal(result._response.status, 200);
    });

    it("should fail to evaluate invalid autoscale formula", async () => {
      const result = await batchClient.pool.evaluateAutoScale(recorder.variable("BASIC_POOL", BASIC_POOL), { autoScaleFormula: "something_useless" });

      assert.equal(
        result.results,
        "$TargetDedicatedNodes=2;$TargetLowPriorityNodes=0;$NodeDeallocationOption=requeue"
      );
      //assert.equal(result._response.status, 200);
    });

    it("should disable autoscale successfully", async () => {
      const result = await batchClient.pool.disableAutoScale(recorder.variable("BASIC_POOL", BASIC_POOL));

      //assert.equal(result._response.status, 200);
    });
  });

  describe("Pool operations (advanced)", async () => {
    it("should create a second pool successfully", async () => {
      const pool = {
        id: recorder.variable("TEST_POOL3", TEST_POOL3),
        vmSize: VMSIZE_SMALL,
        cloudServiceConfiguration: { osFamily: "4" }
      };
      const result = await batchClient.pool.add(pool);
      //assert.equal(result._response.status, 201);
    });

    it("should list pools without filters", async () => {
      const listResult = await batchClient.pool.list();
      const poolCount = await (await getListObj(listResult)).length;

      assert.isAtLeast(poolCount, 2);
      //assert.equal(result._response.status, 200);
    });

    it.skip("should list a maximum number of pools", async () => {
      try {
        const options = { poolListOptions: { maxResults: 1 } };
        let listResultIterator = await batchClient.pool.list(options);

        let poolCounter = 0;
        for await (const pool of listResultIterator) {
          ++poolCounter;
        }


        assert.equal(poolCounter, 1);
      }
      catch (error) {
        console.log(error);
        throw error;
      }


      //assert.equal(result._response.status, 200);
      //result = await client.pool.listNext(result.odatanextLink!);

      // assert.lengthOf(result, 1);
      // assert.equal(result._response.status, 200);
    });

    it("should fail to list pools with invalid max", async () => {
      const options = { poolListOptions: { maxResults: -5 } };
      try {
        await batchClient.pool.list(options);
      }
      catch (error) {
        console.log(error);
        assert.equal(error.message, '"options.poolListOptions.maxResults" with value "-5" should satisfy the constraint "InclusiveMinimum": 1.')
      }

    });

    it("should list pools according to filter", async () => {
      const poolId = recorder.variable("BASIC_POOL", BASIC_POOL)
      const options = {
        poolListOptions: {
          filter: `startswith(id,'${poolId}')`,
          select: "id,state",
          expand: "stats"
        }
      };
      const resultListIterator = await batchClient.pool.list(options);
      const listOfPools = await getListObj(resultListIterator);

      assert.lengthOf(listOfPools, 1);
      assert.equal(listOfPools[0].id, poolId);
      assert.equal(listOfPools[0].state, "active");
      assert.isUndefined(listOfPools[0].allocationState);
      assert.isUndefined(listOfPools[0].vmSize);
      //assert.equal(result._response.status, 200);
    });

    it("should check that pool exists successfully", async () => {
      const result = await batchClient.pool.exists(recorder.variable("BASIC_POOL", BASIC_POOL));

    });

    it("should start pool resizing successfully", async () => {
      try {
        const poolId = recorder.variable("TEST_POOL3", TEST_POOL3);
        let poolResizing = true;
        let poolResult;
        while (poolResizing) {
          poolResult = await batchClient.pool.get(poolId);
          if (poolResult.allocationState === "steady") {
            //poolResizing = false;
            break;
          }
          else {
            await wait(POLLING_INTERVAL * 2);
          }
        }

        const options = { targetDedicatedNodes: 3, targetLowPriorityNodes: 2 };
        const result = await batchClient.pool.resize(poolId, options);

      }
      catch (error) {
        console.log(error);
        throw error;
      }

      //assert.equal(result._response.status, 202);
    });

    it("should stop pool resizing successfully", async () => {
      try {
        const result = await batchClient.pool.stopResize(recorder.variable("TEST_POOL3", TEST_POOL3));
      }
      catch (error) {
        console.log(error);
        throw error;
      }


      //assert.equal(result._response.status, 202);
    });

    it("should get pool lifetime statistics", async () => {
      const result = await batchClient.pool.getAllLifetimeStatistics();

      assert.isDefined(result.usageStats);
      assert.isDefined(result.resourceStats);
      //assert.equal(result._response.status, 200);
    });

    it("should list pools usage metrics", async () => {
      const listUsageIterator = await batchClient.pool.listUsageMetrics();
      const poolUsageList = await getListObj(listUsageIterator);

      assert.isAtLeast(poolUsageList.length, 1);
      //assert.equal(result._response.status, 200);
    });
  });

  describe("Job operations (basic)", async () => {
    it("should create a job successfully", async () => {
      const jobId = recorder.variable("JOB_NAME", JOB_NAME);
      const poolId = recorder.variable("BASIC_POOL", BASIC_POOL);
      const options = { id: jobId, poolInfo: { poolId: poolId } };
      const result = await batchClient.job.add(options);

      const getResult = await batchClient.job.get(jobId);
      assert.equal(getResult.state, "active");
      assert.equal(getResult.poolInfo?.poolId, poolId);
      assert.equal(getResult.allowTaskPreemption, false);

    });

    it("should update a job successfully", async () => {
      const options = {
        priority: 500,
        constraints: { maxTaskRetryCount: 3 },
        poolInfo: { poolId: recorder.variable("BASIC_POOL", BASIC_POOL) }
      };

      try {
        const result = await batchClient.job.update(recorder.variable("JOB_NAME", JOB_NAME), options);
      }
      catch (error) {
        console.log(error);
        throw error
      }

    });

    it("should patch a job successfully", async () => {
      const options = {
        priority: 600,
        constraints: { maxTaskRetryCount: 3 },
        poolInfo: { poolId: recorder.variable("BASIC_POOL", BASIC_POOL) }
      };
      const result = await batchClient.job.update(recorder.variable("JOB_NAME", JOB_NAME), options);

      //assert.equal(result._response.status, 200);
    });

  });

  describe("Task operations", async () => {
    it("should create a task with container settings successfully", async () => {
      const jobId = recorder.variable("JOB_NAME", JOB_NAME);

      const taskSettings = {
        id: "taskWithContainerSettings",
        commandLine: "cat /etc/centos-release",
        containerSettings: { imageName: "centos" }
      };
      try {
        const result2 = await batchClient.task.add(jobId, taskSettings);
        const getResult = await batchClient.task.get(jobId, taskSettings.id);
        assert.equal(getResult.containerSettings?.imageName, taskSettings.containerSettings.imageName);
        assert.equal(getResult.commandLine, taskSettings.commandLine);

        await batchClient.task.delete(jobId, taskSettings.id);
      }
      catch (error) {
        console.log(error);
        throw error;
      }

    });

    it("should create a task with exit conditions successfully", async () => {

      const jobId = "JobWithAutoComplete";
      const taskId = "TaskWithAutoComplete";
      const job: BatchJob = {
        id: jobId,
        poolInfo: {
          poolId: "dummypool"
        },
        onAllTasksComplete: "noaction",
        onTaskFailure: "performexitoptionsjobaction",
        usesTaskDependencies: true
      };

      try {
        const result1 = await batchClient.job.add(job);

        const task: BatchTask = {
          id: taskId,
          commandLine: "echo Hello World",
          exitConditions: {
            default: {
              jobAction: "terminate",
              dependencyAction: "satisfy"
            },
            exitCodes: [
              {
                code: 1,
                exitOptions: {
                  jobAction: "none",
                  dependencyAction: "block"
                }
              }
            ]
          }
        };

        await batchClient.task.add(jobId, task);

        const result3 = await batchClient.task.get(jobId, taskId);

        assert.equal(result3.exitConditions!.default!.jobAction, "terminate");
        assert.equal(result3.exitConditions!.default!.dependencyAction, "satisfy");
        assert.equal(result3.exitConditions!.exitCodes![0].code, 1);
        assert.equal(result3.exitConditions!.exitCodes![0].exitOptions.jobAction, "none");
        assert.equal(result3.exitConditions!.exitCodes![0].exitOptions.dependencyAction, "block");
      }
      catch (error) {
        console.log(error);
        throw error;
      }
      finally {
        await batchClient.job.delete(jobId);
      }

    });


    it("should create a task successfully", async () => {
      const task = {
        id: recorder.variable("TASK_NAME", TASK_NAME),
        commandLine: "cmd /c echo hello > taskHello.txt"
      };
      const result = await batchClient.task.add(recorder.variable("JOB_NAME", JOB_NAME), task);
    });

    it("should terminate a task successfully", async () => {
      const result = await batchClient.task.terminate(recorder.variable("JOB_NAME", JOB_NAME), recorder.variable("TASK_NAME", TASK_NAME));
    });

    it("should create a second task with output files successfully", async () => {
      const container =
        "https://teststorage.blob.core.windows.net/batch-sdk-test?se=2017-05-05T23%3A48%3A11Z&sv=2016-05-31&sig=fwsWniANVb/KSQQdok%2BbT7gR79iiZSG%2BGkw9Rsd5efY";
      const outputs = [
        {
          filePattern: "../stdout.txt",
          destination: {
            container: { containerUrl: container, path: "taskLogs/output.txt", uploadHeaders: [{ name: "x-ms-blob-content-type", value: "text/plain" }, { name: "x-ms-blob-content-language", value: "en-US" },] }
          },
          uploadOptions: { uploadCondition: "taskCompletion" }
        },
        {
          file_pattern: "../stderr.txt",
          destination: {
            container: { containerUrl: container, path: "taskLogs/error.txt" }
          },
          uploadOptions: { uploadCondition: "taskFailure" }
        }
      ];

      const options = {
        id: recorder.variable("TASK2_NAME", TASK2_NAME),
        commandLine: "cmd /c echo hello world",
        output_files: outputs
      };

      const result = await batchClient.task.add(recorder.variable("JOB_NAME", JOB_NAME), options);

    });

    it("should reactivate a task successfully", async () => {
      const result = await batchClient.task.reactivate(recorder.variable("JOB_NAME", JOB_NAME), recorder.variable("TASK_NAME", TASK_NAME));
    });

    it("should update a task successfully", async () => {
      const result = await batchClient.task.update(recorder.variable("JOB_NAME", JOB_NAME), recorder.variable("TASK2_NAME", TASK2_NAME), TASK_UPDATE_OPTIONS);
    });

    it("should list all tasks successfully", async () => {
      const result = await batchClient.task.list(recorder.variable("JOB_NAME", JOB_NAME));
      var taskCounter = 0;

      for await (const item of result) {
        assert.equal(item.constraints!.maxTaskRetryCount, TASK_UPDATE_OPTIONS.constraints.maxTaskRetryCount);
        ++taskCounter;
      }

      assert.equal(taskCounter, 2);
    });

    it("should get task reference successfully", async () => {
      const taskId = recorder.variable("TASK_NAME", TASK_NAME)
      const result = await batchClient.task.get(recorder.variable("JOB_NAME", JOB_NAME), taskId);

      assert.equal(result.id, taskId);
      assert.equal(result.constraints?.maxTaskRetryCount, TASK_UPDATE_OPTIONS.constraints.maxTaskRetryCount);

    });

    it("should add a task with an application package reference successfully", async () => {
      const jobId = recorder.variable("JOB_NAME", JOB_NAME);
      const task = {
        id: "Task-AppPackage",
        commandLine: "cmd /c echo hello world",
        applicationPackageReferences: [
          {
            applicationId: "my_application_id"
          }
        ]
      };
      try {
        const result1 = await batchClient.task.add(jobId, task);
        const result2 = await batchClient.task.get(jobId, task.id);
        assert.isDefined(result2.applicationPackageReferences);
      }
      catch (error) {
        console.log(error);
        throw error;
      }

    });

    it("should create a task with authentication token settings successfully", async () => {
      const jobId = recorder.variable("JOB_NAME", JOB_NAME);
      const taskId = "TaskWithAuthTokenSettings";
      const task: BatchTask = {
        id: taskId,
        commandLine: "cmd /c echo Hello World",
        authenticationTokenSettings: {
          access: ["job"]
        }
      };

      const result = await batchClient.task.add(jobId, task);

      const result2 = await batchClient.task.get(jobId, taskId);

      assert.isDefined(result2.authenticationTokenSettings);
      assert.isDefined(result2.authenticationTokenSettings!.access);
      assert.lengthOf(result2.authenticationTokenSettings!.access!, 1);
      assert.equal(result2.authenticationTokenSettings!.access![0], "job");
    });

    it("should create a task with a user identity successfully", async () => {
      const jobId = recorder.variable("JOB_NAME", JOB_NAME);
      const taskId = "TaskWithUserIdentity";
      const task = {
        id: taskId,
        // This command should return a non-zero exit code for a non-admin user
        commandLine: "cmd /c net session >nul 2>&1",
        userIdentity: {
          userName: nonAdminPoolUser
        }
      };

      await batchClient.task.add(jobId, task);

      let result2: TaskGetResponse;
      while (true) {
        result2 = await batchClient.task.get(jobId, taskId);
        if (result2.executionInfo !== undefined && result2.executionInfo.result != undefined) {
          break;
        } else {
          await wait(POLLING_INTERVAL * 2);
        }
      }
      assert.isDefined(result2.userIdentity);
      assert.equal(result2.userIdentity!.userName, nonAdminPoolUser);
      assert.isDefined(result2.executionInfo);
      assert.equal(result2.executionInfo!.result, "failure");
      assert.notEqual(result2.executionInfo!.exitCode, 0);
    }).timeout(LONG_TEST_TIMEOUT);

    it("should count tasks sucessfully", async () => {
      const result = await batchClient.job.getTaskCounts(recorder.variable("JOB_NAME", JOB_NAME));

      assert.isDefined(result.taskCounts.active);
      assert.isDefined(result.taskCounts.completed);
    });

    //TODO: Need to test with actual subtasks
    // it("should list sub tasks successfully", async () => {
    //   const result = await client.task.listSubtasks(JOB_NAME, TASK_NAME);

    //   assert.equal(result._response.status, 200);
    // });

  });

  describe.skip("File operations", async () => {
    it("should list files from task successfully", async () => {
      try {
        let result: TaskGetResponse;
        const jobId = recorder.variable("JOB_NAME", JOB_NAME);
        const taskId = recorder.variable("TASK2_NAME", TASK2_NAME);
        while (true) {
          result = await batchClient.task.get(jobId, taskId);
          if (result.executionInfo !== undefined && result.executionInfo.result != undefined) {
            break;
          } else {
            await wait(POLLING_INTERVAL * 2);
          }
        }

        const result2 = await batchClient.file.listFromTask(jobId, taskId);
        var fileCountList = await getListObj(result2);
        assert.isAtLeast(fileCountList.length, 1);
      }
      catch (error) {
        console.log(error);
        throw error;
      }

      //assert.equal(result._response.status, 200);
    });

    it("should get file properties from task successfully", async () => {
      try {
        const result = await batchClient.file.getPropertiesFromTask(recorder.variable("JOB_NAME", JOB_NAME), recorder.variable("TASK2_NAME", TASK2_NAME), "stderr.txt");
      }
      catch (error) {
        console.log(error);
        throw error;
      }


      //assert.equal(result._response.status, 200);
    });

    it("should get file from task successfully", (done) => {
      batchClient.file
        .getFromTask(recorder.variable("JOB_NAME", JOB_NAME), recorder.variable("TASK2_NAME", TASK2_NAME), "stdout.txt")
        .then((result) => {
          //assert.equal(result._response.status, 200);
          readStreamToBuffer(result.readableStreamBody!, function (_err, buff) {
            assert.isAtLeast(buff.length, 1);
            done();
          });
        })
        .catch((error) => {
          assert.fail(error);
        });
    });

    it("should delete file from task successfully", async () => {
      try {
        const result = await batchClient.file.deleteFromTask(recorder.variable("JOB_NAME", JOB_NAME), recorder.variable("TASK2_NAME", TASK2_NAME), "stderr.txt");
      }
      catch (error) {
        console.log(error);
        throw error;
      }


      //assert.equal(result._response.status, 200);
    });

    it("should re-list compute nodes successfully", async () => {
      const result = await batchClient.computeNode.list(recorder.variable("BASIC_POOL", BASIC_POOL));

      let nodeList = [];

      for await (const obj of result) {
        nodeList.push(obj);
      }

      assert.isAtLeast(nodeList.length, 1);

      computeNodes = nodeList.map(function (x) {
        return x.id!;
      });
      //wait(100000);
      // if (!suite.isPlayback) {
      //   console.log('Waiting for nodes to be ready...')
      //   setTimeout(function () {
      //     done();
      //   }, 100000);
      // } else {
      //   done();
      // }
    });

    it("should list files from compute node successfully", async () => {
      try {
        let computeNodeToQuery = computeNodes[1];
        let computeNodeStatusResult;
        while (true) {
          computeNodeStatusResult = await batchClient.computeNode.get(BASIC_POOL, computeNodeToQuery)
          if (computeNodeStatusResult.state === "idle") {
            break;
          } else {
            await wait(POLLING_INTERVAL * 2);
          }
        }
        const result = await batchClient.file.listFromComputeNode(BASIC_POOL, computeNodeToQuery);
        const fileList = await getListObj(result);
        assert.isAtLeast(fileList.length, 1);
      }
      catch (exception) {
        console.log(exception);
        throw exception;
      }
      //assert.equal(result._response.status, 200);
    }).timeout(LONG_TEST_TIMEOUT);

    it("should get file properties from node successfully", async () => {
      try {
        const result = await batchClient.file.getPropertiesFromComputeNode(
          BASIC_POOL,
          computeNodes[1],
          "startup/wd/hello.txt"
        );
      }
      catch (exception) {
        console.log(exception);
        throw exception;
      }


      //assert.equal(result._response.status, 200);
    });

    it("should get file from node successfully", (done) => {
      batchClient.file
        .getFromComputeNode(BASIC_POOL, computeNodes[1], "startup/wd/hello.txt")
        .then((result) => {
          //assert.equal(result._response.status, 200);
          readStreamToBuffer(result.readableStreamBody!, function (_err, buff) {
            assert.isAtLeast(buff.length, 1);
            done();
          });
        })
        .catch((error) => {
          assert.fail(error);
        });
    });

    it("should delete file from node successfully", async () => {
      try {
        const result = await batchClient.file.deleteFromComputeNode(
          BASIC_POOL,
          computeNodes[1],
          "startup/wd/hello.txt"
        );
      }
      catch (exception) {
        console.log(exception);
        throw exception;
      }


      //assert.equal(result._response.status, 200);
    });
  });


  describe.skip("Task cleanup", async () => {
    it("should delete a task successfully", async () => {
      const result = await batchClient.task.delete(JOB_NAME, TASK_NAME);
    });

    it("should add a task with an application package reference successfully", async () => {
      const taskId = "ApplicationPacakgeReferenceTask";
      const task = {
        id: taskId,
        commandLine: "cmd /c echo hello world",
        applicationPackageReferences: [
          {
            applicationId: "my_application_id"
          }
        ]
      };
      const result1 = await batchClient.task.add(JOB_NAME, task);

      const result2 = await batchClient.task.get(JOB_NAME, taskId);
      assert.isDefined(result2.applicationPackageReferences);
    });

    it("should delete a second task successfully", async () => {
      try {
        const result = await batchClient.task.delete(JOB_NAME, TASK2_NAME);
      }
      catch (error) {
        console.log(error);
        throw error;
      }

    });
  });

  describe("Job operations (advanced)", async () => {
    it("should get a job reference successfully", async () => {
      const jobId = recorder.variable("JOB_NAME", JOB_NAME);
      const result = await batchClient.job.get(jobId);

      assert.equal(result.id, jobId);
      assert.equal(result.state, "active");
      assert.equal(result.poolInfo!.poolId, recorder.variable("BASIC_POOL", BASIC_POOL));
      //assert.equal(result._response.status, 200);
    });

    it("should list jobs successfully", async () => {
      const result = await batchClient.job.list();
      const jobList = await getListObj(result);
      assert.isAtLeast(jobList.length, 1);
      //assert.equal(result._response.status, 200);
    });

    it("should fail to job prep+release status", async () => {
      try {
        const result = await batchClient.job.listPreparationAndReleaseTaskStatus(recorder.variable("JOB_NAME", JOB_NAME)).next();
        assert.fail("Expected error to be thrown");
      } catch (error) {
        assert.equal(error.code, "JobPreparationTaskOrReleaseTaskNotSpecified");
      }
    });

    it("should disable a job successfully", async () => {
      const result = await batchClient.job.disable(recorder.variable("JOB_NAME", JOB_NAME), { disableTasks: "requeue" });

      //assert.equal(result._response.status, 202);
    });

    it("should enable a job successfully", async () => {
      const result = await batchClient.job.enable(recorder.variable("JOB_NAME", JOB_NAME));

      //assert.equal(result._response.status, 202);
    });

    it("should terminate a job successfully", async () => {
      const result = await batchClient.job.terminate(recorder.variable("JOB_NAME", JOB_NAME));

      //assert.equal(result._response.status, 202);
    });

    it("should delete a job successfully", async function () {
      const result = await batchClient.job.delete(recorder.variable("JOB_NAME", JOB_NAME));

      //assert.equal(result._response.status, 202);
    })

    it("should get all job statistics successfully", async () => {
      const result = await batchClient.job.getAllLifetimeStatistics();

      assert.isDefined(result.userCPUTime);
      assert.isDefined(result.kernelCPUTime);
      //assert.equal(result._response.status, 200);
    });
  });

  describe.skip("Job schedules", async () => {
    it("should create a job schedule successfully", async () => {
      const options: JobSchedule = {
        id: SCHEDULE,
        jobSpecification: {
          displayName: JOB_NAME,
          poolInfo: { poolId: BASIC_POOL }
        },
        schedule: {
          doNotRunUntil: moment().add(3, "days").toDate(),
          startWindow: duration({ minutes: 6 }).toISOString()
        }
      };

      const result = await batchClient.jobSchedule.add(options);

      //assert.equal(result._response.status, 201);
    });

    it("should list job schedules successfully", async () => {
      const result = await batchClient.jobSchedule.list();
      const jobScheduleList = await getListObj(result);
      assert.equal(jobScheduleList.length, 1);
    });

    it("should list jobs from job schedule successfully", async () => {
      const result = await batchClient.job.listFromJobSchedule(SCHEDULE);
      const jobList = await getListObj(result);
      assert.equal(jobList.length, 0);
    });

    it("should check if a job schedule exists successfully", async () => {
      const result = await batchClient.jobSchedule.exists(SCHEDULE);
    });

    it("should get a job schedule reference successfully", async () => {
      const result = await batchClient.jobSchedule.get(SCHEDULE);

      assert.equal(result.id, SCHEDULE);
      assert.equal(result.state, "active");
      assert.equal(result.jobSpecification?.displayName, JOB_NAME);
    });

    it("should update a job schedule successfully", async () => {
      const options: JobSchedule = {
        schedule: { recurrenceInterval: duration({ hours: 6 }).toISOString() },
        jobSpecification: { poolInfo: { poolId: ADVANCED_POOL } }
      };

      const result = await batchClient.jobSchedule.update(SCHEDULE, options);

      //assert.equal(result._response.status, 200);
    });

    it("should patch a job schedule successfully", async () => {
      const options = {
        schedule: {
          recurrenceInterval: duration({ hours: 3 }).toISOString(),
          startWindow: duration({ hours: 1 }).toISOString()
        }
      };

      const result = await batchClient.jobSchedule.patch(SCHEDULE, options);

      //assert.equal(result._response.status, 200);
    });

    it("should disable a job schedule successfully", async () => {
      const result = await batchClient.jobSchedule.disable(SCHEDULE);

      //assert.equal(result._response.status, 204);
    });

    it("should enable a job schedule successfully", async () => {
      const result = await batchClient.jobSchedule.enable(SCHEDULE);

      //assert.equal(result._response.status, 204);
    });

    it("should terminate a job schedule successfully", async () => {
      const result = await batchClient.jobSchedule.terminate(SCHEDULE);

      // assert.equal(result._response.status, 202);
    });

    it("should delete a job schedule successfully", async () => {
      const result = await batchClient.jobSchedule.delete(SCHEDULE);

      // assert.equal(result._response.status, 202);
    });
  });

  describe("Resource cleanup", () => {
    it("should remove nodes in pool successfully", async () => {
      const options: NodeRemoveParameters = {
        nodeList: computeNodes,
        nodeDeallocationOption: "terminate"
      };
      const result = await batchClient.pool.removeNodes(recorder.variable("BASIC_POOL", BASIC_POOL), options, {
        onResponse: function (rawResponse, flatResponse, error) {
          if (error != null) {
            console.log(error);
            throw error;
          }
          else {
            assert.equal(rawResponse.status, 202);
          }
        }
      });

    });

    it.only("should delete a pool successfully", async function () {
      await batchClient.pool.delete(recorder.variable("BASIC_POOL", BASIC_POOL));
    });

    it("should delete a second pool successfully", async () => {
      await batchClient.pool.delete(recorder.variable("TEST_POOL3", TEST_POOL3));
    })

    it("should delete a third pool successfully", async () => {
      const result = await batchClient.pool.delete(recorder.variable("ENDPOINT_POOL", ENDPOINT_POOL));

      //assert.equal(result._response.status, 202);
    });

    it("should fail to delete a non-existent pool", async () => {
      try {
        await batchClient.pool.delete(recorder.variable("BASIC_POOL", BASIC_POOL));
      } catch (error: any) {
        assert.equal(error.code, "PoolBeingDeleted");
      }
    });

    it.only("should delete a certificate successfully", async function () {
      const result = await batchClient.certificate.delete("sha1", certThumb);
    })

    it("should fail to cancel deleting a certificate", async () => {
      try {
        await batchClient.certificate.cancelDeletion("sha1", certThumb);
      } catch (error: any) {
        assert.equal(error.code, "CertificateBeingDeleted");
      }
    });
  })




})
