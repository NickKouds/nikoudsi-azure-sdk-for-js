/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
import { BatchGeneratedClient, JobAddParameters, JobUpdateParameters, PoolAddParameters, PoolPatchParameters } from "../../src/generated/";
import { Recorder } from "@azure-tools/test-recorder";
import { assert } from "chai";
import { generateClient, createRecorder, useRLCShortcut, generateSharedKeyClient } from "./utils/recordedClient";
//import { isNode } from "@azure/core-util";
import { Context } from "mocha";
import { env } from "process";
import { BatchServiceClient } from "../../src";

// const startDateTime = new Date("2020-02-01T08:00:00.000Z");
// const endDateTime = new Date("2020-03-02T08:00:00.000Z");
// const suffix = isNode ? "node" : "browser";
// const farmerId = `tst103${suffix}`;
// const jobId = `jhjob103${suffix}`;
// const boundaryId = `jhboundary103${suffix}`;

const _SUFFIX = Math.random()
  .toString(16)
  .substr(2, 4);

function getPoolName(type: string) {
  return `jssdktest-${type}-${_SUFFIX}`;
}

const BASIC_POOL = getPoolName("basic");
const VNET_POOL = getPoolName("vnet");
const IMAGE_POOL = getPoolName("image");
const DISK_POOL = getPoolName("datadisk");
const BASIC_POOL_NUM_VMS = 4;
const JOB_NAME = `JSSDKTestJob-${_SUFFIX}`;
const TASK_NAME = `${JOB_NAME}-Task1`;
const TASK_UPDATE_OPTIONS = {
  constraints: { maxTaskRetryCount: 3 }
};
const SCHEDULE = "JSSDKTestSchedule";
const TEST_USER = "JSSDKTestSchedule";
const VMSIZE_A1 = "Standard_A1_v2";
const VMSIZE_D1 = "Standard_D1_v2";
const VMSIZE_SMALL = "Small";

const POLLING_INTERVAL = 5000;
const LONG_TEST_TIMEOUT = 1000000;

describe("Batch Test", () => {
  let recorder: Recorder;
  let batchClient: BatchServiceClient

  beforeEach(async function () {
    recorder = createRecorder(this);
    batchClient = generateSharedKeyClient();
  });

  afterEach(async function () {
    await recorder.stop();
  });


  describe("Basic Pool operations", () => {
    it("Create Batch Pool successfully", async function () {

      const poolParams = {
        id: BASIC_POOL,
        displayName: "Testing local sample",
        vmSize: VMSIZE_D1,
        virtualMachineConfiguration: {
          imageReference: {
            publisher: "Canonical",
            offer: "UbuntuServer",
            sku: "18.04-LTS",
            version: "latest"
          },
          nodeAgentSKUId: "batch.node.ubuntu 18.04"
        },
        targetDedicatedNodes: 4,
        enableAutoScale: false
      };

      let callParams: PoolAddParameters = {
        body: poolParams,
        headers: {}
      };
      let result;
      try {


        if (Boolean(useRLCShortcut)) {
          result = await batchClient.pool.add(callParams);
        }
        else {
          result = await batchClient.path("/pools").post(callParams);
        }
        console.log(result);
        assert.include(["200", "201"], result.status);

        await wait(20000);
      }
      catch (error) {
        console.log(error);
        throw error;
      }


    });

    it("should patch pool parameters successfully", async function () {

      const metadataOptions = [{
        name: "foo2",
        value: "bar2"
      }];

      let callParams: PoolPatchParameters = {
        body: {
          metadata: metadataOptions
        },
        headers: {},

      };
      let result;
      try {


        if (Boolean(useRLCShortcut)) {
          result = await batchClient.pool.patch(BASIC_POOL, callParams);
        }
        else {
          result = await batchClient.path("/pools/{poolId}", BASIC_POOL).patch(callParams);
        }

        assert.equal("200", result.status);

        const getResult = await batchClient.path("/pools/{poolId}", BASIC_POOL).get();

        assert.equal(getResult.body["id"], BASIC_POOL);
        assert.equal(getResult.body["state"], "active");


        for (let index = 0; index < metadataOptions.length; index++) {
          assert.equal(getResult.body["metadata"][index].name, metadataOptions[index].name);
          assert.equal(getResult.body["metadata"][index].value, metadataOptions[index].value);
        }
      }
      catch (error) {
        console.log(error);
        throw error;
      }


    })

    it("should get a pool reference successfully", async () => {
      let result: any;
      let metadata: any;

      const promise = new Promise<void>((resolve) => {
        const timeout = setInterval(async () => {
          result = await batchClient.pool.get(BASIC_POOL);
          metadata = result.body["metadata"][0];
          if (result.body["allocationState"] === "steady") {
            resolve();
            clearTimeout(timeout);
          }
        }, POLLING_INTERVAL);
      });

      await promise;

      assert.equal(result.body["id"], BASIC_POOL);
      assert.equal(result.body["state"], "active");
      assert.equal(result.body["allocationState"], "steady");
      assert.isDefined(result.body["virtualMachineConfiguration"]);
      assert.equal(result.body["virtualMachineConfiguration"].nodeAgentSKUId, "batch.node.ubuntu 18.04");
      assert.equal(result.body["vmSize"].toLowerCase(), VMSIZE_D1.toLowerCase());

      assert.equal(metadata.name, "foo2");
      assert.equal(metadata.value, "bar2");


    });
  })


  describe("Job operations (basic)", async () => {
    it("should create a job successfully", async () => {
      const options = { id: JOB_NAME, poolInfo: { poolId: BASIC_POOL } };
      const callParams: JobAddParameters = {
        body: options,
        headers: {},

      };

      let result;

      if (Boolean(useRLCShortcut)) {
        result = await batchClient.job.add(callParams);

      }
      else {
        result = await batchClient.path("/jobs").post(callParams);
      }

      assert.equal("201", result.status);

      const getResult = await batchClient.job.get(JOB_NAME);
      assert.equal(getResult.body["state"], "active");
      assert.equal(getResult.body["poolInfo"].poolId, BASIC_POOL);
      assert.equal(getResult.body["allowTaskPreemption"], false);

    });

    it("should update a job successfully", async () => {
      const options = {
        priority: 500,
        constraints: { maxTaskRetryCount: 3 },
        poolInfo: { poolId: BASIC_POOL }
      };

      const callParams: JobUpdateParameters = {
        body: options,
        headers: {},
        //Need to add contentType to patch operations
      }
      let result;

      try {
        if (Boolean(useRLCShortcut)) {
          result = await batchClient.job.update(JOB_NAME, callParams);
        }
        else {
          result = await batchClient.path("/jobs/{jobId}", JOB_NAME).patch(callParams);
        }

        assert.equal(result.status, "200");

        const getResult = await batchClient.job.get(JOB_NAME);
        assert.equal(getResult.body["priority"], options.priority);
        assert.equal(getResult.body["constraints"]["maxTaskRetryCount"], options.constraints.maxTaskRetryCount);
      }
      catch (error) {
        console.log(error);
        throw error
      }


    });

  });

  describe("Task operations", async () => {
    it("should create a task successfully", async () => {
      const task = {
        id: TASK_NAME,
        commandLine: "echo hello world"
      };
      const callParams = {
        body: task,
        headers: {}
      };

      let result;
      if (Boolean(useRLCShortcut)) {
        result = await batchClient.task.add(JOB_NAME, callParams)
      }
      else {
        result = await batchClient.path("/jobs/{jobId}/tasks", JOB_NAME).post({
          body: task,
          headers: {}
        });
      }

      assert.equal(result.status, "201");

    });

    it("should update a task successfully", async () => {
      const callParams = {
        body: TASK_UPDATE_OPTIONS,
        headers: {},

      };

      let result;
      if (Boolean(useRLCShortcut)) {
        result = await batchClient.task.update(JOB_NAME, TASK_NAME, callParams);
      }
      else {
        result = await batchClient.path("/jobs/{jobId}/tasks/{taskId}", JOB_NAME, TASK_NAME).put(callParams);
      }


      assert.equal(result.status, "200");
    });

    it("should get task reference successfully", async () => {
      let result;

      if (Boolean(useRLCShortcut)) {
        result = await batchClient.task.get(JOB_NAME, TASK_NAME);
      }
      else {
        result = await batchClient.path("/jobs/{jobId}/tasks/{taskId}", JOB_NAME, TASK_NAME).get();
      }


      assert.equal(result.status, "200");
      assert.equal(result.body["id"], TASK_NAME);
      assert.equal(result.body["constraints"].maxTaskRetryCount, TASK_UPDATE_OPTIONS.constraints.maxTaskRetryCount);
    });
  })

  describe("Resource cleanup", () => {
    it("Delete Batch Pool", async function () {
      let result;

      if (Boolean(useRLCShortcut)) {
        result = await batchClient.pool.delete(BASIC_POOL);
      }
      else {
        result = await batchClient.path("/pools/{poolId}", BASIC_POOL).delete();
      }

      assert.equal(result.status, "202");
    });

    it("Delete Batch Task", async function () {
      let result;

      if (Boolean(useRLCShortcut)) {
        result = await batchClient.task.delete(JOB_NAME, TASK_NAME);
      }
      else {
        result = await batchClient.path("/jobs/{jobId}/tasks/{taskId}", JOB_NAME, TASK_NAME).delete();
      }

      assert.equal(result.status, "200");
    });

    it("Delete Batch Job", async function () {
      let result;

      if (Boolean(useRLCShortcut)) {
        result = await batchClient.job.delete(JOB_NAME);
      }
      else {
        result = await batchClient.path("/jobs/{jobId}", JOB_NAME).delete();
      }

      assert.equal(result.status, "202");
    });

  })

});

const wait = (ms: number): Promise<void> => {
  return new Promise<void>((resolve) => {
    setTimeout(() => {
      resolve();
    }, ms);
  });
};
